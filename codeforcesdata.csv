Question,Solution
"B. Maximal Continuous Rest
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
Each day in Berland consists of $$$n$$$ hours. Polycarp likes time management. That's why he has a fixed schedule for each day — it is a sequence $$$a_1, a_2, \dots, a_n$$$ (each $$$a_i$$$ is either $$$0$$$ or $$$1$$$), where $$$a_i=0$$$ if Polycarp works during the $$$i$$$-th hour of the day and $$$a_i=1$$$ if Polycarp rests during the $$$i$$$-th hour of the day.
Days go one after another endlessly and Polycarp uses the same schedule for each day.
What is the maximal number of continuous hours during which Polycarp rests? It is guaranteed that there is at least one working hour in a day.
Input
The first line contains $$$n$$$ ($$$1 \le n \le 2\cdot10^5$$$) — number of hours per day.
The second line contains $$$n$$$ integer numbers $$$a_1, a_2, \dots, a_n$$$ ($$$0 \le a_i \le 1$$$), where $$$a_i=0$$$ if the $$$i$$$-th hour in a day is working and $$$a_i=1$$$ if the $$$i$$$-th hour is resting. It is guaranteed that $$$a_i=0$$$ for at least one $$$i$$$.
Output
Print the maximal number of continuous hours during which Polycarp rests. Remember that you should consider that days go one after another endlessly and Polycarp uses the same schedule for each day.
Examples
Input

5
1 0 1 0 1

Output

2

Input

6
0 1 0 1 1 0

Output

2

Input

7
1 0 1 1 1 0 1

Output

3

Input

3
0 0 0

Output

0

Note
In the first example, the maximal rest starts in last hour and goes to the first hour of the next day.
In the second example, Polycarp has maximal rest from the $$$4$$$-th to the $$$5$$$-th hour.
In the third example, Polycarp has maximal rest from the $$$3$$$-rd to the $$$5$$$-th hour.
In the fourth example, Polycarp has no rest at all.","#include <bits/stdc++.h> #define ll long long using namespace std; int main(){ ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0); int tt = 1; //cin >> tt; while(tt--){ int n; cin >> n; vector<int> a(n); for(int i = 0; i < n; i++){ cin >> a[i]; } int mx = 0; int current_length = 0; for(int i = 0; i < 2 * n; i++){ if(a[i % n] == 0){ mx = max(mx, current_length); current_length = 0; }else{ current_length++; } } cout << mx << '\n'; } return 0; }"
"B. New Year and Ascent Sequence
time limit per test
2 seconds
memory limit per test
1024 megabytes
input
standard input
output
standard output
A sequence $$$a = [a_1, a_2, \ldots, a_l]$$$ of length $$$l$$$ has an 
ascent
 if there exists a pair of indices $$$(i, j)$$$ such that $$$1 \le i < j \le l$$$ and $$$a_i < a_j$$$. For example, the sequence $$$[0, 2, 0, 2, 0]$$$ has an ascent because of the pair $$$(1, 4)$$$, but the sequence $$$[4, 3, 3, 3, 1]$$$ doesn't have an ascent.
Let's call a concatenation of sequences $$$p$$$ and $$$q$$$ the sequence that is obtained by writing down sequences $$$p$$$ and $$$q$$$ one right after another without changing the order. For example, the concatenation of the $$$[0, 2, 0, 2, 0]$$$ and $$$[4, 3, 3, 3, 1]$$$ is the sequence $$$[0, 2, 0, 2, 0, 4, 3, 3, 3, 1]$$$. The concatenation of sequences $$$p$$$ and $$$q$$$ is denoted as $$$p+q$$$.
Gyeonggeun thinks that sequences with ascents bring luck. Therefore, he wants to make many such sequences for the new year. Gyeonggeun has $$$n$$$ sequences $$$s_1, s_2, \ldots, s_n$$$ which may have different lengths. 
Gyeonggeun will consider all $$$n^2$$$ pairs of sequences $$$s_x$$$ and $$$s_y$$$ ($$$1 \le x, y \le n$$$), and will check if its concatenation $$$s_x + s_y$$$ has an ascent. Note that he may select the same sequence twice, and the order of selection matters.
Please count the number of pairs ($$$x, y$$$) of sequences $$$s_1, s_2, \ldots, s_n$$$ whose concatenation $$$s_x + s_y$$$ contains an ascent.
Input
The first line contains the number $$$n$$$ ($$$1 \le n \le 100\,000$$$) denoting the number of sequences.
The next $$$n$$$ lines contain the number $$$l_i$$$ ($$$1 \le l_i$$$) denoting the length of $$$s_i$$$, followed by $$$l_i$$$ integers $$$s_{i, 1}, s_{i, 2}, \ldots, s_{i, l_i}$$$ ($$$0 \le s_{i, j} \le 10^6$$$) denoting the sequence $$$s_i$$$. 
It is guaranteed that the sum of all $$$l_i$$$ does not exceed $$$100\,000$$$.
Output
Print a single integer, the number of pairs of sequences whose concatenation has an ascent.
Examples
Input

5
1 1
1 1
1 2
1 4
1 3

Output

9

Input

3
4 2 0 2 0
6 9 9 8 8 7 7
1 6

Output

7

Input

10
3 62 24 39
1 17
1 99
1 60
1 64
1 30
2 79 29
2 20 73
2 85 37
1 100

Output

72

Note
For the first example, the following $$$9$$$ arrays have an ascent: $$$[1, 2], [1, 2], [1, 3], [1, 3], [1, 4], [1, 4], [2, 3], [2, 4], [3, 4]$$$. Arrays with the same contents are counted as their occurences.","#include <bits/stdc++.h> using namespace std; using ll = long long; #define all(x) (x).begin(), (x).end() #define rall(x) (x).rbegin(), (x).rend() int main() { ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); ll tc = 1; // cin >> tc; while (tc--) { ll n; cin >> n; vector<vector<ll>> v(n); vector<pair<ll, vector<ll>>> ddd; for (ll z = 0; z < n; z++) { ll l, prev = 1e18, f = 1; cin >> l; for (ll t, x = 0; x < l; x++) { cin >> t; v[z].push_back(t); if (t > prev) { f = 0; } prev = t; } if (f) { ddd.push_back({v[z][0], v[z]}); } } ll sub = 0; sort(rall(ddd)); for (ll x = 0; x < ddd.size(); x++) { ll low = 0, high = ddd.size() - 1, idx = ddd.size(); ll last = ddd[x].second[ddd[x].second.size() - 1]; while (low <= high) { ll mid = (low + high) / 2; if (ddd[mid].first <= last) { high = mid - 1; idx = mid; } else { low = mid + 1; } } sub += (ddd.size() - idx); } ll res = n * n - sub; cout << res << '\n'; } return 0; }"
"B. Just Eat It!
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
Today, Yasser and Adel are at the shop buying cupcakes. There are $$$n$$$ cupcake types, arranged from $$$1$$$ to $$$n$$$ on the shelf, and there are infinitely many of each type. The tastiness of a cupcake of type $$$i$$$ is an integer $$$a_i$$$. There are both tasty and nasty cupcakes, so the tastiness can be positive, zero or negative.
Yasser, of course, wants to try them all, so he will buy exactly one cupcake of each type.
On the other hand, Adel will choose some segment $$$[l, r]$$$ $$$(1 \le l \le r \le n)$$$ that does not include all of cupcakes (he can't choose $$$[l, r] = [1, n]$$$) and buy exactly one cupcake of each of types $$$l, l + 1, \dots, r$$$.
After that they will compare the total tastiness of the cupcakes each of them have bought. Yasser will be happy if the total tastiness of cupcakes he buys is 
strictly
 greater than the total tastiness of cupcakes Adel buys 
regardless of Adel's choice
.
For example, let the tastinesses of the cupcakes be $$$[7, 4, -1]$$$. Yasser will buy all of them, the total tastiness will be $$$7 + 4 - 1 = 10$$$. Adel can choose segments $$$[7], [4], [-1], [7, 4]$$$ or $$$[4, -1]$$$, their total tastinesses are $$$7, 4, -1, 11$$$ and $$$3$$$, respectively. Adel can choose segment with tastiness $$$11$$$, and as $$$10$$$ is not strictly greater than $$$11$$$, Yasser won't be happy :(
Find out if Yasser will be happy after visiting the shop.
Input
Each test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \le t \le 10^4$$$). The description of the test cases follows.
The first line of each test case contains $$$n$$$ ($$$2 \le n \le 10^5$$$).
The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$-10^9 \le a_i \le 10^9$$$), where $$$a_i$$$ represents the tastiness of the $$$i$$$-th type of cupcake.
It is guaranteed that the sum of $$$n$$$ over all test cases doesn't exceed $$$10^5$$$.
Output
For each test case, print ""
YES
"", if the total tastiness of cupcakes Yasser buys will always be 
strictly
 greater than the total tastiness of cupcakes Adel buys regardless of Adel's choice. Otherwise, print ""
NO
"".
Example
Input

3
4
1 2 3 4
3
7 4 -1
3
5 -5 5

Output

YES
NO
NO

Note
In the first example, the total tastiness of any segment Adel can choose is less than the total tastiness of all cupcakes.
In the second example, Adel will choose the segment $$$[1, 2]$$$ with total tastiness $$$11$$$, which is not less than the total tastiness of all cupcakes, which is $$$10$$$.
In the third example, Adel can choose the segment $$$[3, 3]$$$ with total tastiness of $$$5$$$. Note that Yasser's cupcakes' total tastiness is also $$$5$$$, so in that case, the total tastiness of Yasser's cupcakes isn't strictly greater than the total tastiness of Adel's cupcakes.","#include<bits/stdc++.h> using namespace std; int main() { long long t;cin>>t; while(t--) { map<long long,long long> mp; long long n;cin>>n; vector<long long> v(n); long long s1=0,sum=0; long long maxi= LONG_LONG_MIN; long long neg=0; for(long long i=0;i<n;i++) { cin>>v[i]; s1+=v[i]; sum+=v[i]; if(maxi<=sum) { mp[sum]++; maxi=sum; } if(sum<0) { sum=0; neg++; } else if(sum==0) neg++; } // cout<<maxi<<""\n""; // cout<<mp[maxi]<<""\n""; if(s1==maxi && neg==0 && mp[maxi]==1) cout<<""YES\n""; else if(s1>maxi) cout<<""YES\n""; else cout<<""NO\n""; } }"
"B. Numbers on Tree
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
Evlampiy was gifted a rooted tree. The vertices of the tree are numbered from $$$1$$$ to $$$n$$$. Each of its vertices also has an integer $$$a_i$$$ written on it. For each vertex $$$i$$$, Evlampiy calculated $$$c_i$$$ — the number of vertices $$$j$$$ in the subtree of vertex $$$i$$$, such that $$$a_j < a_i$$$. 
Illustration for the second example, the first integer is $$$a_i$$$ and the integer in parentheses is $$$c_i$$$
After the new year, Evlampiy could not remember what his gift was! He remembers the tree and the values of $$$c_i$$$, but he completely forgot which integers $$$a_i$$$ were written on the vertices.
Help him to restore initial integers!
Input
The first line contains an integer $$$n$$$ $$$(1 \leq n \leq 2000)$$$ — the number of vertices in the tree.
The next $$$n$$$ lines contain descriptions of vertices: the $$$i$$$-th line contains two integers $$$p_i$$$ and $$$c_i$$$ ($$$0 \leq p_i \leq n$$$; $$$0 \leq c_i \leq n-1$$$), where $$$p_i$$$ is the parent of vertex $$$i$$$ or $$$0$$$ if vertex $$$i$$$ is root, and $$$c_i$$$ is the number of vertices $$$j$$$ in the subtree of vertex $$$i$$$, such that $$$a_j < a_i$$$.
It is guaranteed that the values of $$$p_i$$$ describe a rooted tree with $$$n$$$ vertices.
Output
If a solution exists, in the first line print ""
YES
"", and in the second line output $$$n$$$ integers $$$a_i$$$ $$$(1 \leq a_i \leq {10}^{9})$$$. If there are several solutions, output any of them. One can prove that if there is a solution, then there is also a solution in which all $$$a_i$$$ are between $$$1$$$ and $$$10^9$$$.
If there are no solutions, print ""
NO
"".
Examples
Input

3
2 0
0 2
2 0

Output

YES
1 2 1 
Input

5
0 1
1 3
2 1
3 0
2 0

Output

YES
2 3 2 1 2","#include <bits/stdc++.h> using namespace std; int n,c[2048],father,child[2048],a[2048]; vector<int> v[2048]; void dfs1(int now, int fa, int tmp) { if(now != fa) a[now] += tmp; if(a[now] >= c[fa] + 1 && now != fa) a[now] ++; for(int i = 0 ; i < v[now].size() ; i ++) { dfs1(v[now][i],fa,tmp); if(now == fa) tmp += child[v[now][i]] + 1; } } int dfs(int idx) { for(int i = 0 ; i < v[idx].size() ; i ++) { int tmp = dfs(v[idx][i]); child[idx] += tmp; } dfs1(idx,idx,0); a[idx] = c[idx] + 1; return child[idx] + 1; } int main() { cin >> n; for (int i = 1 ; i <= n ; i ++) { int f; cin >> f >> c[i]; if (f == 0) father = i; v[f].push_back(i); } dfs(father); int flag = 0; for(int i = 1 ; i <= n ; i ++) if(c[i] > child[i]) flag = 1; if(flag == 0) { cout << ""YES"" << endl; for(int i = 1 ; i <= n ; i ++) cout << a[i] << "" ""; } else cout << ""NO""; return 0; }"
"B. Hyperset
time limit per test
3 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
Bees Alice and Alesya gave beekeeper Polina famous card game ""Set"" as a Christmas present. The deck consists of cards that vary in four features across three options for each kind of feature: number of shapes, shape, shading, and color. In this game, some combinations of three cards are said to make up a 
set
. For every feature — color, number, shape, and shading — the three cards must display that feature as either all the same, or pairwise different. The picture below shows how sets look.
Polina came up with a new game called ""Hyperset"". In her game, there are $$$n$$$ cards with $$$k$$$ features, each feature has three possible values: ""
S
"", ""
E
"", or ""
T
"". The original ""Set"" game can be viewed as ""Hyperset"" with $$$k = 4$$$.
Similarly to the original game, three cards form a 
set
, if all features are the same for all cards or are pairwise different. The goal of the game is to compute the number of ways to choose three cards that form a 
set
.
Unfortunately, winter holidays have come to an end, and it's time for Polina to go to school. Help Polina find the number of sets among the cards lying on the table.
Input
The first line of each test contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 1500$$$, $$$1 \le k \le 30$$$) — number of cards and number of features.
Each of the following $$$n$$$ lines contains a card description: a string consisting of $$$k$$$ letters ""
S
"", ""
E
"", ""
T
"". The $$$i$$$-th character of this string decribes the $$$i$$$-th feature of that card. All cards are distinct.
Output
Output a single integer — the number of ways to choose three cards that form a set.
Examples
Input

3 3
SET
ETS
TSE

Output

1
Input

3 4
SETE
ETSE
TSES

Output

0
Input

5 4
SETT
TEST
EEET
ESTE
STES

Output

2
Note
In the third example test, these two triples of cards are 
sets
:
 
 ""
SETT
"", ""
TEST
"", ""
EEET
"" 
 ""
TEST
"", ""
ESTE
"", ""
STES
""","#include<bits/stdc++.h> using namespace std; // #define int long long string f(string &a,string &b) { int n = a.size(); string res = a; int xorr = 'S'^'E'^'T'; for(int i=0;i<n;i++) { if(a[i]!=b[i]) res[i] = (char)(xorr^a[i]^b[i]); } return res; } void solve() // int solve() { int n,k; cin>>n>>k; vector<string> v(n); set<string> st; for(string &s:v) cin>>s , st.insert(s); int ans = 0; for(int i=0;i<n;i++) for(int j=i+1;j<n;j++) { string res = f(v[i],v[j]); if(st.find(res) != st.end()) ans++; } ans/=3; cout<<ans<<endl; } main() { ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); int t = 1; // cin>>t; while(t--) { solve(); // cout<<solve()<<endl; } return 0; }"
"B. Yet Another Meme Problem
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
You are given two integers $$$A$$$ and $$$B$$$, calculate the number of pairs $$$(a, b)$$$ such that $$$1 \le a \le A$$$, $$$1 \le b \le B$$$, and the equation $$$a \cdot b + a + b = conc(a, b)$$$ is true; $$$conc(a, b)$$$ is the concatenation of $$$a$$$ and $$$b$$$ (for example, $$$conc(12, 23) = 1223$$$, $$$conc(100, 11) = 10011$$$). 
$$$a$$$ and $$$b$$$ should not contain leading zeroes
.
Input
The first line contains $$$t$$$ ($$$1 \le t \le 100$$$) — the number of test cases.
Each test case contains two integers $$$A$$$ and $$$B$$$ $$$(1 \le A, B \le 10^9)$$$.
Output
Print one integer — the number of pairs $$$(a, b)$$$ such that $$$1 \le a \le A$$$, $$$1 \le b \le B$$$, and the equation $$$a \cdot b + a + b = conc(a, b)$$$ is true.
Example
Input


3
1 11
4 2
191 31415926
Output

1
0
1337

Note
There is only one suitable pair in the first test case: $$$a = 1$$$, $$$b = 9$$$ ($$$1 + 9 + 1 \cdot 9 = 19$$$).","#include <bits/stdc++.h> using namespace std; #define ll long long void solution() { ll int A,B; cin >> A >> B; ll int b=9; ll int count=0; ll int p=0; while(b<=B){ count+=A; p++; b+=9*pow(10,p); // cout<<b<<endl; } cout<<count<<endl; } int main() { // Makes input and output fast ios_base :: sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL); // Test cases int T; cin>>T; while(T--) solution(); return 0; }"
"B. Irreducible Anagrams
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
Let's call two strings $$$s$$$ and $$$t$$$ 
anagrams
 of each other if it is possible to rearrange symbols in the string $$$s$$$ to get a string, equal to $$$t$$$.
Let's consider two strings $$$s$$$ and $$$t$$$ 
which are anagrams of each other
. We say that $$$t$$$ is a 
reducible anagram
 of $$$s$$$ if there exists an integer $$$k \ge 2$$$ and $$$2k$$$ non-empty strings $$$s_1, t_1, s_2, t_2, \dots, s_k, t_k$$$ that satisfy the following conditions:
 
 If we write the strings $$$s_1, s_2, \dots, s_k$$$ in order, the resulting string will be equal to $$$s$$$; 
 If we write the strings $$$t_1, t_2, \dots, t_k$$$ in order, the resulting string will be equal to $$$t$$$; 
 For all integers $$$i$$$ between $$$1$$$ and $$$k$$$ inclusive, $$$s_i$$$ and $$$t_i$$$ are anagrams of each other. 
If such strings don't exist, then $$$t$$$ is said to be an 
irreducible anagram
 of $$$s$$$. 
Note that these notions are only defined when $$$s$$$ and $$$t$$$ are anagrams of each other
.
For example, consider the string $$$s = $$$ ""
gamegame
"". Then the string $$$t = $$$ ""
megamage
"" is a reducible anagram of $$$s$$$, we may choose for example $$$s_1 = $$$ ""
game
"", $$$s_2 = $$$ ""
gam
"", $$$s_3 = $$$ ""
e
"" and $$$t_1 = $$$ ""
mega
"", $$$t_2 = $$$ ""
mag
"", $$$t_3 = $$$ ""
e
"":
 
 
On the other hand, we can prove that $$$t = $$$ ""
memegaga
"" is an irreducible anagram of $$$s$$$.
You will be given a string $$$s$$$ and $$$q$$$ queries, represented by two integers $$$1 \le l \le r \le |s|$$$ (where $$$|s|$$$ is equal to the length of the string $$$s$$$). For each query, you should find if the substring of $$$s$$$ formed by characters from the $$$l$$$-th to the $$$r$$$-th has 
at least one
 irreducible anagram.
Input
The first line contains a string $$$s$$$, consisting of lowercase English characters ($$$1 \le |s| \le 2 \cdot 10^5$$$).
The second line contains a single integer $$$q$$$ ($$$1 \le q \le 10^5$$$)  — the number of queries.
Each of the following $$$q$$$ lines contain two integers $$$l$$$ and $$$r$$$ ($$$1 \le l \le r \le |s|$$$), representing a query for the substring of $$$s$$$ formed by characters from the $$$l$$$-th to the $$$r$$$-th.
Output
For each query, print a single line containing ""
Yes
"" (without quotes) if the corresponding substring has at least one irreducible anagram, and a single line containing ""
No
"" (without quotes) otherwise.
Examples
Input

aaaaa
3
1 1
2 4
5 5

Output

Yes
No
Yes

Input

aabbbbbbc
6
1 2
2 4
2 2
1 9
5 7
3 5

Output

No
Yes
Yes
Yes
No
No

Note
In the first sample, in the first and third queries, the substring is ""
a
"", which has itself as an irreducible anagram since two or more non-empty strings cannot be put together to obtain ""
a
"". On the other hand, in the second query, the substring is ""
aaa
"", which has no irreducible anagrams: its only anagram is itself, and we may choose $$$s_1 = $$$ ""
a
"", $$$s_2 = $$$ ""
aa
"", $$$t_1 = $$$ ""
a
"", $$$t_2 = $$$ ""
aa
"" to show that it is a reducible anagram.
In the second query of the second sample, the substring is ""
abb
"", which has, for example, ""
bba
"" as an irreducible anagram.","#include<bits/stdc++.h> using namespace std; typedef long long ll; #define endl '\n' const int maxn=2*1e5+11; const int Maxx=5*1e5+11; const int mod=1e9+7; int t; string s; int q; int l,r; int pre[maxn][30]; void solve() { cin>>s; for(int i=0;i<s.size();++i) { for(int j=1;j<=26;++j) pre[i+1][j]=pre[i][j]; ++pre[i+1][int(s[i]-'a')+1]; } cin>>q; while(q--) { cin>>l>>r; --l,--r; if(s[l]!=s[r]) { cout<<""Yes""<<endl;continue; } if(l==r) {cout<<""Yes""<<endl;continue;} ++l,++r; int num=0; for(int i=1;i<=26;++i) { if(pre[r][i]-pre[l-1][i]) ++num; } if(num>=3) {cout<<""Yes""<<endl;continue;} else {cout<<""No""<<endl;continue;} } } int main() { //scanf(""%d"",&t); ios::sync_with_stdio(false);cin.tie(0); //ios::sync_with_stdio(false);cin.tie(0);cin>>t;while(t--) solve(); return 0; }"
"B. Array Sharpening
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
You're given an array $$$a_1, \ldots, a_n$$$ of $$$n$$$ non-negative integers.
Let's call it 
sharpened
 if and only if there exists an integer $$$1 \le k \le n$$$ such that $$$a_1 < a_2 < \ldots < a_k$$$ and $$$a_k > a_{k+1} > \ldots > a_n$$$. In particular, any strictly increasing or strictly decreasing array is 
sharpened
. For example:
 
 The arrays $$$[4]$$$, $$$[0, 1]$$$, $$$[12, 10, 8]$$$ and $$$[3, 11, 15, 9, 7, 4]$$$ are sharpened; 
 The arrays $$$[2, 8, 2, 8, 6, 5]$$$, $$$[0, 1, 1, 0]$$$ and $$$[2, 5, 6, 9, 8, 8]$$$ are 
not
 sharpened. 
You can do the following operation as many times as you want: choose any 
strictly positive
 element of the array, and decrease it by one. Formally, you can choose any $$$i$$$ ($$$1 \le i \le n$$$) such that $$$a_i>0$$$ and assign $$$a_i := a_i - 1$$$.
Tell if it's possible to make the given array 
sharpened
 using some number (possibly zero) of these operations.
Input
The input consists of multiple test cases. The first line contains a single integer $$$t$$$ ($$$1 \le t \le 15\ 000$$$)  — the number of test cases. The description of the test cases follows.
The first line of each test case contains a single integer $$$n$$$ ($$$1 \le n \le 3 \cdot 10^5$$$).
The second line of each test case contains a sequence of $$$n$$$ non-negative integers $$$a_1, \ldots, a_n$$$ ($$$0 \le a_i \le 10^9$$$).
It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$3 \cdot 10^5$$$.
Output
For each test case, output a single line containing ""
Yes
"" (without quotes) if it's possible to make the given array sharpened using the described operations, or ""
No
"" (without quotes) otherwise.
Example
Input

10
1
248618
3
12 10 8
6
100 11 15 9 7 8
4
0 1 1 0
2
0 0
2
0 1
2
1 0
2
1 1
3
0 1 0
3
1 0 1

Output

Yes
Yes
Yes
No
No
Yes
Yes
Yes
Yes
No

Note
In the first and the second test case of the first test, the given array is already sharpened.
In the third test case of the first test, we can transform the array into $$$[3, 11, 15, 9, 7, 4]$$$ (decrease the first element $$$97$$$ times and decrease the last element $$$4$$$ times). It is sharpened because $$$3 < 11 < 15$$$ and $$$15 > 9 > 7 > 4$$$.
In the fourth test case of the first test, it's impossible to make the given array sharpened.","#include <bits/stdc++.h> using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(0); int t; cin >> t; while (t--) { int n; cin >> n; vector<int> fin(n); for (int i = 0; i < n; ++i) cin >> fin[i]; int pref_num = -1, suff_num = n; for (int i = 0; i < n; ++i) { if (fin[i] < i) break; pref_num = i; } for (int i = n-1; i >= 0; --i) { if (fin[i] < (n-1)-i) break; suff_num = i; } if (suff_num <= pref_num) // Non-empty intersection cout << ""Yes\n""; else cout << ""No\n""; } }"
"B. Aroma's Search
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
THE SxPLAY & KIVΛ - 漂流
 
KIVΛ & Nikki Simmons - Perspectives
With a new body, our idol Aroma White (or should we call her Kaori Minamiya?) begins to uncover her lost past through the OS space.
The space can be considered a 2D plane, with an infinite number of data nodes, indexed from $$$0$$$, with their coordinates defined as follows:
 
 The coordinates of the $$$0$$$-th node is $$$(x_0, y_0)$$$ 
 For $$$i > 0$$$, the coordinates of $$$i$$$-th node is $$$(a_x \cdot x_{i-1} + b_x, a_y \cdot y_{i-1} + b_y)$$$ 
Initially Aroma stands at the point $$$(x_s, y_s)$$$. She can stay in OS space for at most $$$t$$$ seconds, because after this time she has to warp back to the real world. She 
doesn't
 need to return to the entry point $$$(x_s, y_s)$$$ to warp home.
While within the OS space, Aroma can do the following actions:
 
 From the point $$$(x, y)$$$, Aroma can move to one of the following points: $$$(x-1, y)$$$, $$$(x+1, y)$$$, $$$(x, y-1)$$$ or $$$(x, y+1)$$$. This action requires $$$1$$$ second. 
 If there is a data node at where Aroma is staying, she can collect it. We can assume this action costs $$$0$$$ seconds. Of course, each data node can be collected at most once. 
Aroma wants to collect as many data as possible before warping back. Can you help her in calculating the maximum number of data nodes she could collect within $$$t$$$ seconds?
Input
The first line contains integers $$$x_0$$$, $$$y_0$$$, $$$a_x$$$, $$$a_y$$$, $$$b_x$$$, $$$b_y$$$ ($$$1 \leq x_0, y_0 \leq 10^{16}$$$, $$$2 \leq a_x, a_y \leq 100$$$, $$$0 \leq b_x, b_y \leq 10^{16}$$$), which define the coordinates of the data nodes.
The second line contains integers $$$x_s$$$, $$$y_s$$$, $$$t$$$ ($$$1 \leq x_s, y_s, t \leq 10^{16}$$$) – the initial Aroma's coordinates and the amount of time available.
Output
Print a single integer — the maximum number of data nodes Aroma can collect within $$$t$$$ seconds.
Examples
Input

1 1 2 3 1 0
2 4 20

Output

3
Input

1 1 2 3 1 0
15 27 26

Output

2
Input

1 1 2 3 1 0
2 2 1

Output

0
Note
In all three examples, the coordinates of the first $$$5$$$ data nodes are $$$(1, 1)$$$, $$$(3, 3)$$$, $$$(7, 9)$$$, $$$(15, 27)$$$ and $$$(31, 81)$$$ (remember that nodes are numbered from $$$0$$$).
In the first example, the optimal route to collect $$$3$$$ nodes is as follows: 
 
 Go to the coordinates $$$(3, 3)$$$ and collect the $$$1$$$-st node. This takes $$$|3 - 2| + |3 - 4| = 2$$$ seconds. 
 Go to the coordinates $$$(1, 1)$$$ and collect the $$$0$$$-th node. This takes $$$|1 - 3| + |1 - 3| = 4$$$ seconds. 
 Go to the coordinates $$$(7, 9)$$$ and collect the $$$2$$$-nd node. This takes $$$|7 - 1| + |9 - 1| = 14$$$ seconds. 
In the second example, the optimal route to collect $$$2$$$ nodes is as follows: 
 
 Collect the $$$3$$$-rd node. This requires no seconds. 
 Go to the coordinates $$$(7, 9)$$$ and collect the $$$2$$$-th node. This takes $$$|15 - 7| + |27 - 9| = 26$$$ seconds. 
In the third example, Aroma can't collect any nodes. She should have taken proper rest instead of rushing into the OS space like that.","#include<bits/stdc++.h> using namespace std; typedef long long ll; #define endl '\n' const int maxn=1e5+11; const int Maxx=1e5+11; const int mod=1e9+7; //int t; ll xo,yo,ax,ay,bx,by; ll xs,ys,t; void solve() { cin>>xo>>yo>>ax>>ay>>bx>>by; cin>>xs>>ys>>t; vector<pair<ll,ll>>v; v.emplace_back(xo,yo); pair<ll,ll>pi=make_pair(xo,yo); while(1) { if((ll(1e17)-bx)/pi.first<ax||(ll(1e17)-by)/pi.second<ay) break; ll px=ax*pi.first*1ll+bx; ll py=ay*pi.second*1ll+by; v.emplace_back(px,py); pi=make_pair(px,py); } //cout<<int(v.size())<<endl; int ans=0; for(int i=0;i<v.size();++i) { for(int j=i;j<v.size();++j) { for(int k=i;k<=j;++k) { ll sum=abs(xs-v[k].first)+abs(ys-v[k].second); sum+=abs(v[i].first-v[j].first)+abs(v[i].second-v[j].second); sum+=min(abs(v[i].first-v[k].first)+abs(v[i].second-v[k].second),abs(v[j].first-v[k].first)+abs(v[j].second-v[k].second)); if(sum<=t) { ans=max(ans,j-i+1); } } } } cout<<ans<<endl; } int main() { //scanf(""%d"",&t); ios::sync_with_stdio(false);cin.tie(0); //ios::sync_with_stdio(false);cin.tie(0);cin>>t;while(t--) solve(); return 0; }"
"B. JOE is on TV!
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
3R2 - Standby for Action
Our dear Cafe's owner, JOE Miller, will soon take part in a new game TV-show ""1 vs. $$$n$$$""!
The game goes in rounds, where in each round the host asks JOE and his opponents a common question. All participants failing to answer are eliminated. The show ends when only JOE remains (we assume that JOE never answers a question wrong!).
For each question JOE answers, if there are $$$s$$$ ($$$s > 0$$$) opponents remaining and $$$t$$$ ($$$0 \le t \le s$$$) of them make a mistake on it, JOE receives $$$\displaystyle\frac{t}{s}$$$ dollars, and consequently there will be $$$s - t$$$ opponents left for the next question.
JOE wonders what is the maximum possible reward he can receive in the best possible scenario. Yet he has little time before show starts, so can you help him answering it instead?
Input
The first and single line contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$), denoting the number of JOE's opponents in the show.
Output
Print a number denoting the maximum prize (in dollars) JOE could have.
Your answer will be considered correct if it's absolute or relative error won't exceed $$$10^{-4}$$$. In other words, if your answer is $$$a$$$ and the jury answer is $$$b$$$, then it must hold that $$$\frac{|a - b|}{max(1, b)} \le 10^{-4}$$$.
Examples
Input

1

Output

1.000000000000

Input

2

Output

1.500000000000

Note
In the second example, the best scenario would be: one contestant fails at the first question, the other fails at the next one. The total reward will be $$$\displaystyle \frac{1}{2} + \frac{1}{1} = 1.5$$$ dollars.",#include<bits/stdc++.h> using namespace std; int main() { ios_base::sync_with_stdio(false); cin.tie(NULL); int n; cin>>n; double ans=0.0; for(int i=1;i<=n;i++) { ans+=1.0/i; } cout<<setprecision(12)<<ans; return 0; }
"B. Collecting Packages
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
There is a robot in a warehouse and $$$n$$$ packages he wants to collect. The warehouse can be represented as a coordinate grid. Initially, the robot stays at the point $$$(0, 0)$$$. The $$$i$$$-th package is at the point $$$(x_i, y_i)$$$. It is guaranteed that there are no two packages at the same point. It is also guaranteed that the point $$$(0, 0)$$$ doesn't contain a package.
The robot is semi-broken and only can move up ('
U
') and right ('
R
'). In other words, in one move the robot can go from the point $$$(x, y)$$$ to the point ($$$x + 1, y$$$) or to the point $$$(x, y + 1)$$$.
As we say above, the robot wants to collect all $$$n$$$ packages (
in arbitrary order
). He wants to do it with the minimum possible number of moves. If there are several possible traversals, the robot wants to choose the lexicographically smallest path.
The string $$$s$$$ of length $$$n$$$ is lexicographically less than the string $$$t$$$ of length $$$n$$$ if there is some index $$$1 \le j \le n$$$ that for all $$$i$$$ from $$$1$$$ to $$$j-1$$$ $$$s_i = t_i$$$ and $$$s_j < t_j$$$. It is the standard comparison of string, like in a dictionary. Most programming languages compare strings in this way.
Input
The first line of the input contains an integer $$$t$$$ ($$$1 \le t \le 100$$$) — the number of test cases. Then test cases follow.
The first line of a test case contains one integer $$$n$$$ ($$$1 \le n \le 1000$$$) — the number of packages.
The next $$$n$$$ lines contain descriptions of packages. The $$$i$$$-th package is given as two integers $$$x_i$$$ and $$$y_i$$$ ($$$0 \le x_i, y_i \le 1000$$$) — the $$$x$$$-coordinate of the package and the $$$y$$$-coordinate of the package.
It is guaranteed that there are no two packages at the same point. It is also guaranteed that the point $$$(0, 0)$$$ doesn't contain a package.
The sum of all values $$$n$$$ over test cases in the test doesn't exceed $$$1000$$$.
Output
Print the answer for each test case.
If it is impossible to collect all $$$n$$$ packages in some order starting from ($$$0,0$$$), print ""
NO
"" on the first line.
Otherwise, print ""
YES
"" in the first line. Then print the 
shortest
 path — a string consisting of characters '
R
' and '
U
'. Among all such paths choose the lexicographically smallest path.
Note that in this problem ""
YES
"" and ""
NO
"" can be only uppercase words, i.e. ""
Yes
"", ""
no
"" and ""
YeS
"" are not acceptable
.
Example
Input

3
5
1 3
1 2
3 3
5 5
4 3
2
1 0
0 1
1
4 3

Output

YES
RUUURRRRUU
NO
YES
RRRRUUU

Note
For the first test case in the example the optimal path 
RUUURRRRUU
 is shown below:","#include<bits/stdc++.h> using namespace std; #define int long long #define float double signed main(){ int t=1; cin>>t; while(t--){ int n; cin>>n; map<int,pair<int,int>> mp; string ans=""YES"",line=""""; for(int i=0;i<n;i++){ int a,b;cin>>a>>b; pair<int,int> pa; auto it=mp.find(a); if(it==mp.end()){ pa={b,b}; mp[a]=pa; } else{ pa={min(mp[a].first,b),max(mp[a].second,b)}; mp[a]=pa; } } int x=0,y=0; for(auto it=mp.begin();it!=mp.end();it++){ int a=(*it).first,b_min=(*it).second.first,b_max=(*it).second.second; if(b_min<y){ans=""NO"";break;} while(a>x){x++;line+='R';} while(b_max>y){line+='U';y++;} } cout<<ans<<endl; if(ans==""NO"")continue; cout<<line<<endl; } return 0; }"
"B. Infinite Prefixes
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
You are given string $$$s$$$ of length $$$n$$$ consisting of 
0
-s and 
1
-s. You build an infinite string $$$t$$$ as a concatenation of an infinite number of strings $$$s$$$, or $$$t = ssss \dots$$$ For example, if $$$s =$$$ 
10010
, then $$$t =$$$ 
100101001010010
...
Calculate the number of prefixes of $$$t$$$ with 
balance
 equal to $$$x$$$. The balance of some string $$$q$$$ is equal to $$$cnt_{0, q} - cnt_{1, q}$$$, where $$$cnt_{0, q}$$$ is the number of occurrences of 
0
 in $$$q$$$, and $$$cnt_{1, q}$$$ is the number of occurrences of 
1
 in $$$q$$$. The number of such prefixes can be infinite; if it is so, you must say that.
A prefix is a string consisting of several first letters of a given string, without any reorders. An empty prefix is also a valid prefix. For example, the string ""abcd"" has 5 prefixes: empty string, ""a"", ""ab"", ""abc"" and ""abcd"".
Input
The first line contains the single integer $$$T$$$ ($$$1 \le T \le 100$$$) — the number of test cases.
Next $$$2T$$$ lines contain descriptions of test cases — two lines per test case. The first line contains two integers $$$n$$$ and $$$x$$$ ($$$1 \le n \le 10^5$$$, $$$-10^9 \le x \le 10^9$$$) — the length of string $$$s$$$ and the desired balance, respectively.
The second line contains the binary string $$$s$$$ ($$$|s| = n$$$, $$$s_i \in \{\text{0}, \text{1}\}$$$).
It's guaranteed that the total sum of $$$n$$$ doesn't exceed $$$10^5$$$.
Output
Print $$$T$$$ integers — one per test case. For each test case print the number of prefixes or $$$-1$$$ if there is an infinite number of such prefixes.
Example
Input

4
6 10
010010
5 3
10101
1 0
0
2 0
01

Output

3
0
1
-1

Note
In the first test case, there are 3 good prefixes of $$$t$$$: with length $$$28$$$, $$$30$$$ and $$$32$$$.","#include<bits/stdc++.h> using namespace std; #define X ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); #define int long long void solve() { int n, m; cin >> n >> m; string s; cin >> s; vector<int> arr(n); int one = 0; int zero = 0; for (int e = 0; e < n; e++) { if (s[e] == '0')zero++; else one++; arr[e] = zero - one; } int ans = 0; if (m == 0)ans++; int ans1 = 0; for (int e = 0; e < n; e++) { if (s[e] == '0')ans1++; else ans1--; if (ans1 == m && arr[n - 1] == 0) { ans = -1; break; } if (ans1 == m || (((m - ans1) * arr[n - 1] > 0) && ((m - ans1) % arr[n - 1] == 0)))ans++; } cout << ans << ""\n""; } int32_t main() { X; int t; cin >> t; while (t--) { solve(); } return 0; }"
"B. Food Buying
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
Mishka wants to buy some food in the nearby shop. Initially, he has $$$s$$$ burles on his card. 
Mishka can perform the following operation any number of times (possibly, zero): choose some 
positive integer number
 $$$1 \le x \le s$$$, buy food that costs exactly $$$x$$$ burles and obtain $$$\lfloor\frac{x}{10}\rfloor$$$ burles as a cashback (in other words, Mishka spends $$$x$$$ burles and obtains $$$\lfloor\frac{x}{10}\rfloor$$$ back). The operation $$$\lfloor\frac{a}{b}\rfloor$$$ means $$$a$$$ divided by $$$b$$$ rounded down.
It is guaranteed that you can always buy some food that costs $$$x$$$ for any possible value of $$$x$$$.
Your task is to say the maximum number of burles Mishka can spend if he buys food optimally.
For example, if Mishka has $$$s=19$$$ burles then the maximum number of burles he can spend is $$$21$$$. Firstly, he can spend $$$x=10$$$ burles, obtain $$$1$$$ burle as a cashback. Now he has $$$s=10$$$ burles, so can spend $$$x=10$$$ burles, obtain $$$1$$$ burle as a cashback and spend it too.
You have to answer $$$t$$$ independent test cases.
Input
The first line of the input contains one integer $$$t$$$ ($$$1 \le t \le 10^4$$$) — the number of test cases.
The next $$$t$$$ lines describe test cases. Each test case is given on a separate line and consists of one integer $$$s$$$ ($$$1 \le s \le 10^9$$$) — the number of burles Mishka initially has.
Output
For each test case print the answer on it — the maximum number of burles Mishka can spend if he buys food optimally.
Example
Input

6
1
10
19
9876
12345
1000000000

Output

1
11
21
10973
13716
1111111111",#include <bits/stdc++.h> using namespace std; int main(){ int n; cin >> n; while(n--){ int a; cin >> a; int sisa=0; int ans=0; while((a+sisa)>=10){ sisa=a/10; ans+=(a/10)*10; a%=10; a+=sisa; } cout << ans+a << endl; } }
"B. Aerodynamic
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
Guy-Manuel and Thomas are going to build a polygon spaceship.
 
You're given a 
strictly convex
 (i. e. no three points are collinear) polygon $$$P$$$ which is defined by coordinates of its vertices. Define $$$P(x,y)$$$ as a polygon obtained by translating $$$P$$$ by vector $$$\overrightarrow {(x,y)}$$$. The picture below depicts an example of the translation:
Define $$$T$$$ as a set of points which is the union of all $$$P(x,y)$$$ such that the origin $$$(0,0)$$$ lies in $$$P(x,y)$$$ (both strictly inside and on the boundary). There is also an equivalent definition: a point $$$(x,y)$$$ lies in $$$T$$$ only if there are two points $$$A,B$$$ in $$$P$$$ such that $$$\overrightarrow {AB} = \overrightarrow {(x,y)}$$$. One can prove $$$T$$$ is a polygon too. For example, if $$$P$$$ is a regular triangle then $$$T$$$ is a regular hexagon. At the picture below $$$P$$$ is drawn in black and some $$$P(x,y)$$$ which contain the origin are drawn in colored: 
The spaceship has the best aerodynamic performance if $$$P$$$ and $$$T$$$ are similar.
 Your task is to check whether the polygons $$$P$$$ and $$$T$$$ are 
similar
.
Input
The first line of input will contain a single integer $$$n$$$ ($$$3 \le n \le 10^5$$$) — the number of points.
The $$$i$$$-th of the next $$$n$$$ lines contains two integers $$$x_i, y_i$$$ ($$$|x_i|, |y_i| \le 10^9$$$), denoting the coordinates of the $$$i$$$-th vertex.
It is guaranteed that these points are listed in counterclockwise order and these points form a strictly convex polygon.
Output
Output 
""YES""
 in a separate line, if $$$P$$$ and $$$T$$$ are similar. Otherwise, output 
""NO""
 in a separate line. You can print each letter in any case (upper or lower).
Examples
Input

4
1 0
4 1
3 4
0 3

Output

YES
Input

3
100 86
50 0
150 0

Output

nO
Input

8
0 0
1 0
2 1
3 3
4 6
3 6
2 5
1 3

Output

YES
Note
The following image shows the first sample: both $$$P$$$ and $$$T$$$ are squares. The second sample was shown in the statements.","#include <iostream> #include <vector> int n; std::vector<int> x, y; int main() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cin >> n; if (n % 2 == 1) { std::cout << ""NO\n""; return 0; } x.resize(n); y.resize(n); for (int i = 0; i < n; ++i) std::cin >> x[i] >> y[i]; int x0 = x[0] + x[n / 2]; int y0 = y[0] + y[n / 2]; for (int i = 0; i < n / 2; ++i) { if (x[i] + x[i + n / 2] != x0 || y[i] + y[i + n / 2] != y0) { std::cout << ""NO\n""; return 0; } } std::cout << ""YES\n""; return 0; }"
"B. Letter A
time limit per test
1 second
memory limit per test
64 megabytes
input
standard input
output
standard output
Little Petya learns how to write. The teacher gave pupils the task to write the letter 
A
 on the sheet of paper. It is required to check whether Petya really had written the letter 
A
.
You are given three segments on the plane. They form the letter 
A
 if the following conditions hold:
 
 Two segments have common endpoint (lets call these segments first and second), while the third segment connects two points on the different segments. 
 The angle between the first and the second segments is greater than 
0
 and do not exceed 
90
 degrees. 
 The third segment divides each of the first two segments in proportion not less than 
1 / 4
 (i.e. the ratio of the length of the shortest part to the length of the longest part is not less than 
1 / 4
). 
Input
The first line contains one integer 
t
 (
1 ≤ 
t
 ≤ 10000
) — the number of test cases to solve. Each case consists of three lines. Each of these three lines contains four space-separated integers — coordinates of the endpoints of one of the segments. All coordinates do not exceed 
10
8
 by absolute value. All segments have positive length.
Output
Output one line for each test case. Print «
YES
» (without quotes), if the segments form the letter 
A
 and «
NO
» otherwise.
Examples
Input
3
4 4 6 0
4 1 5 2
4 0 4 4
0 0 0 6
0 6 2 -4
1 1 0 1
0 0 0 5
0 5 2 -1
1 2 0 1
Output
YES
NO
YES","#include <algorithm> #include <iostream> using namespace std; long long cross(int x0, int y0, int x1, int y1) { return (long long) x0 * y1 - (long long) x1 * y0; } long long cross(int x0, int y0, int x1, int y1, int x2, int y2) { return cross(x1 - x0, y1 - y0, x2 - x0, y2 - y0); } long long dot(int x0, int y0, int x1, int y1) { return (long long) x0 * x1 + (long long) y0 * y1; } bool check2(int xl0, int yl0, int xr0, int yr0, int xl1, int yl1, int xr1, int yr1, int xl2, int yl2, int xr2, int yr2) { if (xl0 != xl1 || yl0 != yl1) return false; if (xr0 == xr1 && yr0 == yr1) return false; if (dot(xr0 - xl0, yr0 - yl0, xr1 - xl1, yr1 - yl1) < 0) return false; if (cross(xl0, yl0, xr0, yr0, xl2, yl2)) return false; if (cross(xl1, yl1, xr1, yr1, xr2, yr2)) return false; if (xl2 < xl0 && xl2 < xr0) return false; if (xl2 > xl0 && xl2 > xr0) return false; if (yl2 < yl0 && yl2 < yr0) return false; if (yl2 > yl0 && yl2 > yr0) return false; if (xr2 < xl1 && xr2 < xr1) return false; if (xr2 > xl1 && xr2 > xr1) return false; if (yr2 < yl1 && yr2 < yr1) return false; if (yr2 > yl1 && yr2 > yr1) return false; int l, r; if (xl0 != xr0) { l = xl0 - xl2; r = xl2 - xr0; } else { l = yl0 - yl2; r = yl2 - yr0; } l = abs(l); r = abs(r); if (l > r) swap(l, r); if (l * 4 < r) return false; if (xl1 != xr1) { l = xl1 - xr2; r = xr2 - xr1; } else { l = yl1 - yr2; r = yr2 - yr1; } l = abs(l); r = abs(r); if (l > r) swap(l, r); if (l * 4 < r) { return false; } return true; } bool check1(int xl0, int yl0, int xr0, int yr0, int xl1, int yl1, int xr1, int yr1, int xl2, int yl2, int xr2, int yr2) { if (check2(xl0, yl0, xr0, yr0, xl1, yl1, xr1, yr1, xl2, yl2, xr2, yr2)) return true; if (check2(xr0, yr0, xl0, yl0, xl1, yl1, xr1, yr1, xl2, yl2, xr2, yr2)) return true; if (check2(xl0, yl0, xr0, yr0, xr1, yr1, xl1, yl1, xl2, yl2, xr2, yr2)) return true; if (check2(xl0, yl0, xr0, yr0, xl1, yl1, xr1, yr1, xr2, yr2, xl2, yl2)) return true; if (check2(xl0, yl0, xr0, yr0, xr1, yr1, xl1, yl1, xr2, yr2, xl2, yl2)) return true; if (check2(xr0, yr0, xl0, yl0, xl1, yl1, xr1, yr1, xr2, yr2, xl2, yl2)) return true; if (check2(xr0, yr0, xl0, yl0, xr1, yr1, xl1, yl1, xl2, yl2, xr2, yr2)) return true; if (check2(xr0, yr0, xl0, yl0, xr1, yr1, xl1, yl1, xr2, yr2, xl2, yl2)) return true; return false; } bool check0(int xl0, int yl0, int xr0, int yr0, int xl1, int yl1, int xr1, int yr1, int xl2, int yl2, int xr2, int yr2) { if (check1(xl0, yl0, xr0, yr0, xl1, yl1, xr1, yr1, xl2, yl2, xr2, yr2)) return true; if (check1(xl1, yl1, xr1, yr1, xl2, yl2, xr2, yr2, xl0, yl0, xr0, yr0)) return true; if (check1(xl2, yl2, xr2, yr2, xl0, yl0, xr0, yr0, xl1, yl1, xr1, yr1)) return true; return false; } int main() { int t; cin >> t; for (int h = 0; h < t; h++) { int xl0, yl0, xr0, yr0; cin >> xl0 >> yl0 >> xr0 >> yr0; int xl1, yl1, xr1, yr1; cin >> xl1 >> yl1 >> xr1 >> yr1; int xl2, yl2, xr2, yr2; cin >> xl2 >> yl2 >> xr2 >> yr2; cout << (check0(xl0, yl0, xr0, yr0, xl1, yl1, xr1, yr1, xl2, yl2, xr2, yr2) ? ""YES"" : ""NO"") << '\n'; } return 0; }"
"B. Assigning to Classes
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
Reminder: the 
median
 of the array $$$[a_1, a_2, \dots, a_{2k+1}]$$$ of odd number of elements is defined as follows: let $$$[b_1, b_2, \dots, b_{2k+1}]$$$ be the elements of the array in the sorted order. Then median of this array is equal to $$$b_{k+1}$$$.
There are $$$2n$$$ students, the $$$i$$$-th student has skill level $$$a_i$$$. It's 
not guaranteed
 that all skill levels are distinct.
Let's define 
skill level of a class
 as the median of skill levels of students of the class.
As a principal of the school, you would like to assign each student to one of the $$$2$$$ classes such that each class has 
odd number of students
 (not divisible by $$$2$$$). The number of students in the classes may be equal or different, by your choice. Every student has to be assigned to exactly one class. Among such partitions, you want to choose one in which the absolute difference between skill levels of the classes is minimized.
What is the minimum possible absolute difference you can achieve?
Input
Each test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \le t \le 10^4$$$). The description of the test cases follows.
The first line of each test case contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of students halved.
The second line of each test case contains $$$2n$$$ integers $$$a_1, a_2, \dots, a_{2 n}$$$ ($$$1 \le a_i \le 10^9$$$) — skill levels of students.
It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$10^5$$$.
Output
For each test case, output a single integer, the minimum possible absolute difference between skill levels of two classes of odd sizes.
Example
Input

3
1
1 1
3
6 5 4 1 2 3
5
13 4 20 13 2 5 8 3 17 16

Output

0
1
5

Note
In the first test, there is only one way to partition students — one in each class. The absolute difference of the skill levels will be $$$|1 - 1| = 0$$$.
In the second test, one of the possible partitions is to make the first class of students with skill levels $$$[6, 4, 2]$$$, so that the skill level of the first class will be $$$4$$$, and second with $$$[5, 1, 3]$$$, so that the skill level of the second class will be $$$3$$$. Absolute difference will be $$$|4 - 3| = 1$$$.
Note that you can't assign like $$$[2, 3]$$$, $$$[6, 5, 4, 1]$$$ or $$$[]$$$, $$$[6, 5, 4, 1, 2, 3]$$$ because classes have even number of students.
$$$[2]$$$, $$$[1, 3, 4]$$$ is also not possible because students with skills $$$5$$$ and $$$6$$$ aren't assigned to a class.
In the third test you can assign the students in the following way: $$$[3, 4, 13, 13, 20], [2, 5, 8, 16, 17]$$$ or $$$[3, 8, 17], [2, 4, 5, 13, 13, 16, 20]$$$. Both divisions give minimal possible absolute difference.","#include <bits/stdc++.h> #include <iostream> #include <vector> using namespace std; typedef long long ll; #define vi vector<int> int main() { int t; cin>>t; while(t--){ int n; cin>>n; int a[2*n]; for(int i=0;i<2*n;i++){ cin>>a[i]; } sort(a,a+(2*n)); // // cout<<a[n]<<"" ""<<a[n+1]<<endl; cout<<abs(a[n-1]-a[n])<<endl;; } return 0; }"
"B. Motarack's Birthday
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
Dark is going to attend Motarack's birthday. Dark decided that the gift he is going to give to Motarack is an array $$$a$$$ of $$$n$$$ non-negative integers.
Dark created that array $$$1000$$$ years ago, so some elements in that array disappeared. Dark knows that Motarack hates to see an array that has two adjacent elements with a high absolute difference between them. He doesn't have much time so he wants to choose an integer $$$k$$$ ($$$0 \leq k \leq 10^{9}$$$) and replaces all missing elements in the array $$$a$$$ with $$$k$$$.
Let $$$m$$$ be the maximum absolute difference between all adjacent elements (i.e. the maximum value of $$$|a_i - a_{i+1}|$$$ for all $$$1 \leq i \leq n - 1$$$) in the array $$$a$$$ after Dark replaces all missing elements with $$$k$$$.
Dark should choose an integer $$$k$$$ so that $$$m$$$ is minimized. Can you help him?
Input
The input consists of multiple test cases. The first line contains a single integer $$$t$$$ ($$$1 \leq t \leq 10^4$$$)  — the number of test cases. The description of the test cases follows.
The first line of each test case contains one integer $$$n$$$ ($$$2 \leq n \leq 10^{5}$$$) — the size of the array $$$a$$$.
The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$-1 \leq a_i \leq 10 ^ {9}$$$). If $$$a_i = -1$$$, then the $$$i$$$-th integer is missing. It is guaranteed that at least one integer is missing in every test case.
It is guaranteed, that the sum of $$$n$$$ for all test cases does not exceed $$$4 \cdot 10 ^ {5}$$$.
Output
Print the answers for each test case in the following format:
You should print two integers, the minimum possible value of $$$m$$$ and an integer $$$k$$$ ($$$0 \leq k \leq 10^{9}$$$) that makes the maximum absolute difference between adjacent elements in the array $$$a$$$ equal to $$$m$$$.
Make sure that after replacing all the missing elements with $$$k$$$, the maximum absolute difference between adjacent elements becomes $$$m$$$.
If there is more than one possible $$$k$$$, you can print any of them.
Example
Input

7
5
-1 10 -1 12 -1
5
-1 40 35 -1 35
6
-1 -1 9 -1 3 -1
2
-1 -1
2
0 -1
4
1 -1 3 -1
7
1 -1 7 5 2 -1 5

Output

1 11
5 35
3 6
0 42
0 0
1 2
3 4

Note
In the first test case after replacing all missing elements with $$$11$$$ the array becomes $$$[11, 10, 11, 12, 11]$$$. The absolute difference between any adjacent elements is $$$1$$$. It is impossible to choose a value of $$$k$$$, such that the absolute difference between any adjacent element will be $$$\leq 0$$$. So, the answer is $$$1$$$.
In the third test case after replacing all missing elements with $$$6$$$ the array becomes $$$[6, 6, 9, 6, 3, 6]$$$.
 
 $$$|a_1 - a_2| = |6 - 6| = 0$$$; 
 $$$|a_2 - a_3| = |6 - 9| = 3$$$; 
 $$$|a_3 - a_4| = |9 - 6| = 3$$$; 
 $$$|a_4 - a_5| = |6 - 3| = 3$$$; 
 $$$|a_5 - a_6| = |3 - 6| = 3$$$. 
So, the maximum difference between any adjacent elements is $$$3$$$.","#include <bits/stdc++.h> using namespace std; #define oo 1000000010 #define mod 1000000007 const int N = 300010; int n , arr[N] ; void solve(){ int mn = oo , mx = -oo; scanf(""%d"",&n); for(int i=0;i<n;i++){ scanf(""%d"",&arr[i]); } for(int i = 0;i<n;i++){ if(i > 0 && arr[i] == -1 && arr[i - 1] != -1) mn = min(mn , arr[i - 1]) , mx = max(mx , arr[i - 1]); if(i < n - 1 && arr[i] == - 1 && arr[i + 1] != -1) mn = min(mn , arr[i + 1]) , mx = max(mx , arr[i + 1]); } int res = (mx + mn) / 2; int ans = 0; for(int i=0;i<n;i++){ if(arr[i] == -1) arr[i] = res; if(i) ans = max(ans,abs(arr[i] - arr[i - 1])); } printf(""%d %d\n"",ans,res); } int main(){ int t; cin >> t; while(t--){ solve(); } return 0; }"
"B. National Project
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
Your company was appointed to lay new asphalt on the highway of length $$$n$$$. You know that every day you can either repair one unit of the highway (lay new asphalt over one unit of the highway) or skip repairing.
Skipping the repair is necessary because of the climate. The climate in your region is periodical: there are $$$g$$$ days when the weather is good and if you lay new asphalt these days it becomes high-quality pavement; after that, the weather during the next $$$b$$$ days is bad, and if you lay new asphalt these days it becomes low-quality pavement; again $$$g$$$ good days, $$$b$$$ bad days and so on.
You can be sure that you start repairing at the start of a good season, in other words, days $$$1, 2, \dots, g$$$ are good.
You don't really care about the quality of the highway, you just want to make sure that 
at least half of the highway
 will have high-quality pavement. For example, if the $$$n = 5$$$ then at least $$$3$$$ units of the highway should have high quality; if $$$n = 4$$$ then at least $$$2$$$ units should have high quality.
What is the minimum number of days is needed to finish the repair of 
the whole highway
?
Input
The first line contains a single integer $$$T$$$ ($$$1 \le T \le 10^4$$$) — the number of test cases.
Next $$$T$$$ lines contain test cases — one per line. Each line contains three integers $$$n$$$, $$$g$$$ and $$$b$$$ ($$$1 \le n, g, b \le 10^9$$$) — the length of the highway and the number of good and bad days respectively.
Output
Print $$$T$$$ integers — one per test case. For each test case, print the minimum number of days required to repair 
the whole highway if at least half of it should have high quality
.
Example
Input

3
5 1 1
8 10 10
1000000 1 1000000

Output

5
8
499999500000

Note
In the first test case, you can just lay new asphalt each day, since days $$$1, 3, 5$$$ are good.
In the second test case, you can also lay new asphalt each day, since days $$$1$$$-$$$8$$$ are good.","#include<bits/stdc++.h> #define ll long long int #define pii pair<ll,ll> using namespace std ; void solve() { ll n,g,b ; cin>>n>>g>>b ; ll good_days = n/2/g*g + (ll)(ceil(n/2.0) - n/2/g*g); ll bad_days = ((n/2/g-1)*b) + (ceil(n/2.0) - n/2/g*g != 0 ? b : 0); ll rem_days = max(0LL,(n-good_days-bad_days)) ; cout<<good_days+bad_days+rem_days<<endl; // cout<<good_days<<"" ""<<bad_days<<endl; } int main(){ ios::sync_with_stdio(0); cin.tie(0); ll T ; cin>>T ; while(T--){ solve() ; } } bool isPowerOfTwo (int x) { return x && (!(x&(x-1))); }"
"B. Longest Palindrome
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
Returning back to problem solving, Gildong is now studying about palindromes. He learned that a 
palindrome
 is a string that is the same as its reverse. For example, strings ""
pop
"", ""
noon
"", ""
x
"", and ""
kkkkkk
"" are palindromes, while strings ""
moon
"", ""
tv
"", and ""
abab
"" are not. 
An empty string is also a palindrome.
Gildong loves this concept so much, so he wants to play with it. He has $$$n$$$ 
distinct
 strings of equal length $$$m$$$. He wants to discard some of the strings (possibly none or all) and reorder the remaining strings so that the concatenation becomes a palindrome. He also wants the palindrome to be as long as possible. Please help him find one.
Input
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le n \le 100$$$, $$$1 \le m \le 50$$$) — the number of strings and the length of each string.
Next $$$n$$$ lines contain a string of length $$$m$$$ each, consisting of lowercase Latin letters only. All strings are 
distinct
.
Output
In the first line, print the length of the longest palindrome string you made.
In the second line, print that palindrome. If there are multiple answers, print any one of them. If the palindrome is empty, print an empty line or don't print this line at all.
Examples
Input

3 3
tab
one
bat

Output

6
tabbat

Input

4 2
oo
ox
xo
xx

Output

6
oxxxxo

Input

3 5
hello
codef
orces

Output

0


Input

9 4
abab
baba
abcd
bcde
cdef
defg
wxyz
zyxw
ijji

Output

20
ababwxyzijjizyxwbaba

Note
In the first example, ""
battab
"" is also a valid answer.
In the second example, there can be 4 different valid answers including the sample output. We are not going to provide any hints for what the others are.
In the third example, the empty string is the only valid palindrome string.","#include <bits/stdc++.h> using namespace std; #define sz(a) ((int) (a).size()) #define L(i, j, k) for(int i = (j); i <= (k); ++i) #define R(i, j, k) for(int i = (j); i >= (k); --i) #define endl '\n' #define pb push_back #define all(x) (x).begin(),(x).end() typedef long long ll; const int N=2e5; ll gcd (ll a, ll b) { if (b == 0) return a; else return gcd (b, a % b); } bool f(string s){ for(int i=0;i<s.size()/2;i++){ if(s[i]!=s[s.size()-i-1]) return false; } return true; } int main() { ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); ll n,m; cin>>n>>m; bool t[n]; string s[n]; string x; bool tx=0; vector <string> ans; for(int i=0;i<n;i++) { cin>>s[i]; t[i]=0; if(tx==false&&f(s[i])){ x=s[i]; tx=true; } } for(int i=0;i<n;i++){ if(t[i]==0){ for(int j=0;j<n;j++){ if(i==j) continue; if(t[j]==1) continue; string a=s[j]; reverse(a.begin(), a.end()); if(s[i]==a){ t[i]=1; t[j]=1; ans.pb(s[i]); } } } } cout<<ans.size()*2*m + ll(tx)*m<<""\n""; for(int i=0;i<ans.size();i++) cout<<ans[i]; if(tx==true) cout<<x; for(int i=ans.size()-1;i>=0;i--){ for(int j=ans[i].size()-1;j>=0;j--){ cout<<ans[i][j]; } } }"
"B. Kuroni and Simple Strings
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
Now that Kuroni has reached 10 years old, he is a big boy and doesn't like arrays of integers as presents anymore. This year he wants a Bracket sequence as a Birthday present. More specifically, he wants a bracket sequence so complex that no matter how hard he tries, he will not be able to remove a simple subsequence!
We say that a string formed by $$$n$$$ characters 
'('
 or 
')'
 is 
simple
 if its length $$$n$$$ is even and positive, its first $$$\frac{n}{2}$$$ characters are 
'('
, and its last $$$\frac{n}{2}$$$ characters are 
')'
. For example, the strings 
()
 and 
(())
 are simple, while the strings 
)(
 and 
()()
 are not simple.
Kuroni will be given a string formed by characters 
'('
 and 
')'
 (the given string is not necessarily simple). An operation consists of choosing a subsequence of the characters of the string that forms a simple string and removing all the characters of this subsequence from the string. 
Note that this subsequence doesn't have to be continuous
. For example, he can apply the operation to the string 
')
(
)
(
()
))
'
, to choose a subsequence of bold characters, as it forms a simple string 
'(())'
, delete these bold characters from the string and to get 
'))()'
. 
Kuroni has to perform the minimum possible number of operations on the string, in such a way that no more operations can be performed on the remaining string. The resulting string 
does not
 have to be empty.
Since the given string is too large, Kuroni is unable to figure out how to minimize the number of operations. Can you help him do it instead?
A sequence of characters $$$a$$$ is a subsequence of a string $$$b$$$ if $$$a$$$ can be obtained from $$$b$$$ by deletion of several (possibly, zero or all) characters.
Input
The only line of input contains a string $$$s$$$ ($$$1 \le |s| \le 1000$$$) formed by characters 
'('
 and 
')'
, where $$$|s|$$$ is the length of $$$s$$$.
Output
In the first line, print an integer $$$k$$$  — the minimum number of operations you have to apply. Then, print $$$2k$$$ lines describing the operations in the following format:
For each operation, print a line containing an integer $$$m$$$  — the number of characters in the subsequence you will remove.
Then, print a line containing $$$m$$$ integers $$$1 \le a_1 < a_2 < \dots < a_m$$$  — the indices of the characters you will remove. All integers must be less than or equal to the length of the current string, and the corresponding subsequence must form a simple string.
If there are multiple valid sequences of operations with the smallest $$$k$$$, you may print any of them.
Examples
Input

(()((

Output

1
2
1 3 

Input

)(

Output

0

Input

(()())

Output

1
4
1 2 5 6 

Note
In the first sample, the string is '
(
(
)
((
'. The operation described corresponds to deleting the bolded subsequence. The resulting string is '
(((
', and no more operations can be performed on it. Another valid answer is choosing indices $$$2$$$ and $$$3$$$, which results in the same final string.
In the second sample, it is already impossible to perform any operations.","#include<bits/stdc++.h> using namespace std; int main(){ ios_base::sync_with_stdio(0); cin.tie(0); string brackets; cin >> brackets; int length = brackets.length(); int left = 0, right = length - 1; vector<int> ans; while (left < right){ while (left < right && brackets[left] == ')'){ left++; } while (left < right && brackets[right] == '('){ right--; } if (left < right){ ans.push_back(left + 1); ans.push_back(right + 1); } left++; right--; } sort(ans.begin(), ans.end()); if (ans.size() > 0){ cout<<1<<""\n""; cout<<ans.size()<<""\n""; for (int index: ans){ cout<<index<<"" ""; } }else{ cout<<0<<""\n""; } cout<<""\n""; return 0; }"
"B. Cow and Friend
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
Bessie has way too many friends because she is everyone's favorite cow! Her new friend Rabbit is trying to hop over so they can play! 
More specifically, he wants to get from $$$(0,0)$$$ to $$$(x,0)$$$ by making multiple hops. He is only willing to hop from one point to another point on the 2D plane if the Euclidean distance between the endpoints of a hop is one of its $$$n$$$ favorite numbers: $$$a_1, a_2, \ldots, a_n$$$. What is the minimum number of hops Rabbit needs to get from $$$(0,0)$$$ to $$$(x,0)$$$? Rabbit may land on points with non-integer coordinates. It can be proved that Rabbit can always reach his destination.
Recall that the Euclidean distance between points $$$(x_i, y_i)$$$ and $$$(x_j, y_j)$$$ is $$$\sqrt{(x_i-x_j)^2+(y_i-y_j)^2}$$$.
For example, if Rabbit has favorite numbers $$$1$$$ and $$$3$$$ he could hop from $$$(0,0)$$$ to $$$(4,0)$$$ in two hops as shown below. Note that there also exists other valid ways to hop to $$$(4,0)$$$ in $$$2$$$ hops (e.g. $$$(0,0)$$$ $$$\rightarrow$$$ $$$(2,-\sqrt{5})$$$ $$$\rightarrow$$$ $$$(4,0)$$$).
 
 
Here is a graphic for the first example. Both hops have distance $$$3$$$, one of Rabbit's favorite numbers.
 
In other words, each time Rabbit chooses some number $$$a_i$$$ and hops with distance equal to $$$a_i$$$ in any direction he wants. The same number can be used multiple times.
Input
The input consists of multiple test cases. The first line contains an integer $$$t$$$ ($$$1 \le t \le 1000$$$)  — the number of test cases. Next $$$2t$$$ lines contain test cases — two lines per test case.
The first line of each test case contains two integers $$$n$$$ and $$$x$$$ ($$$1 \le n \le 10^5$$$, $$$1 \le x \le 10^9$$$)  — the number of favorite numbers and the distance Rabbit wants to travel, respectively.
The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \le a_i \le 10^9$$$)  — Rabbit's favorite numbers. It is guaranteed that the favorite numbers are distinct.
It is guaranteed that the sum of $$$n$$$ over all the test cases will not exceed $$$10^5$$$.
Output
For each test case, print a single integer — the minimum number of hops needed.
Example
Input


4
2 4
1 3
3 12
3 4 5
1 5
5
2 10
15 4
Output

2
3
1
2

Note
The first test case of the sample is shown in the picture above. Rabbit can hop to $$$(2,\sqrt{5})$$$, then to $$$(4,0)$$$ for a total of two hops. Each hop has a distance of $$$3$$$, which is one of his favorite numbers.
In the second test case of the sample, one way for Rabbit to hop $$$3$$$ times is: $$$(0,0)$$$ $$$\rightarrow$$$ $$$(4,0)$$$ $$$\rightarrow$$$ $$$(8,0)$$$ $$$\rightarrow$$$ $$$(12,0)$$$.
In the third test case of the sample, Rabbit can hop from $$$(0,0)$$$ to $$$(5,0)$$$.
In the fourth test case of the sample, Rabbit can hop: $$$(0,0)$$$ $$$\rightarrow$$$ $$$(5,10\sqrt{2})$$$ $$$\rightarrow$$$ $$$(10,0)$$$.","#include <bits/stdc++.h> using namespace std; int main() { int t; cin>>t; for (int i = 0; i < t; i++) { int n,x; cin>>n>>x; vector<int>a(n); bool ans = true; for (int i = 0; i < n; i++) { cin>>a[i]; if(x == a[i]) { ans = false; } } if(!ans) { cout<<""1""<<endl; } else { int temp = *max_element(a.begin(),a.end()); cout<<max(2,((x + temp - 1)/temp))<<endl; } } return 0; }"
"B. Double Elimination
time limit per test
2 seconds
memory limit per test
512 megabytes
input
standard input
output
standard output
The biggest event of the year – Cota 2 world championship ""The Innernational"" is right around the corner. $$$2^n$$$ teams will compete in a double-elimination format (please, carefully read problem statement even if you know what is it) to identify the champion. 
Teams are numbered from $$$1$$$ to $$$2^n$$$ and will play games one-on-one. All teams start in the upper bracket.
All upper bracket matches will be held played between teams that haven't lost any games yet. Teams are split into games by team numbers. Game winner advances in the next round of upper bracket, losers drop into the lower bracket.
Lower bracket starts with $$$2^{n-1}$$$ teams that lost the first upper bracket game. Each lower bracket round consists of two games. In the first game of a round $$$2^k$$$ teams play a game with each other (teams are split into games by team numbers). $$$2^{k-1}$$$ loosing teams are eliminated from the championship, $$$2^{k-1}$$$ winning teams are playing $$$2^{k-1}$$$ teams that got eliminated in this round of upper bracket (again, teams are split into games by team numbers). As a result of each round both upper and lower bracket have $$$2^{k-1}$$$ teams remaining. See example notes for better understanding.
Single remaining team of upper bracket plays with single remaining team of lower bracket in grand-finals to identify championship winner.
You are a fan of teams with numbers $$$a_1, a_2, ..., a_k$$$. You want the championship to have as many games with your favourite teams as possible. Luckily, you can affect results of every championship game the way you want. What's maximal possible number of championship games that include teams you're fan of?
Input
First input line has two integers $$$n, k$$$ — $$$2^n$$$ teams are competing in the championship. You are a fan of $$$k$$$ teams ($$$2 \le n \le 17; 0 \le k \le 2^n$$$).
Second input line has $$$k$$$ distinct integers $$$a_1, \ldots, a_k$$$ — numbers of teams you're a fan of ($$$1 \le a_i \le 2^n$$$).
Output
Output single integer — maximal possible number of championship games that include teams you're fan of.
Examples
Input

3 1
6

Output

6

Input

3 3
1 7 8

Output

11

Input

3 4
1 3 5 7

Output

14

Note
On the image, each game of the championship is denoted with an English letter ($$$a$$$ to $$$n$$$). Winner of game $$$i$$$ is denoted as $$$Wi$$$, loser is denoted as $$$Li$$$. Teams you're a fan of are highlighted with red background.
In the first example, team $$$6$$$ will play in 6 games if it looses the first upper bracket game (game $$$c$$$) and wins all lower bracket games (games $$$h, j, l, m$$$). 
In the second example, teams $$$7$$$ and $$$8$$$ have to play with each other in the first game of upper bracket (game $$$d$$$). Team $$$8$$$ can win all remaining games in upper bracket, when teams $$$1$$$ and $$$7$$$ will compete in the lower bracket. 
In the third example, your favourite teams can play in all games of the championship.","#include<iostream> #include<cstring> #include<algorithm> using namespace std; using LL = long long; const int maxn = 1e6 + 5; bool v[maxn]; int main(){ #ifdef LOCAL freopen(""data.in"", ""r"", stdin); freopen(""data.out"", ""w"", stdout); #endif cin.tie(0); cout.tie(0); ios::sync_with_stdio(0); const int INF = 1e9; int n, k; cin >> n >> k; if (k == 0){ cout << 0 << '\n'; return 0; } vector<array<int, 4> > dp(1 << n, {0, -INF, -INF, -INF}); for(int i = 1; i <= k; i++){ int x; cin >> x; int s = (1 << n - 1) + (x - 1) / 2; if (dp[s][1] != -INF) dp[s][3] = 1; else dp[s][1] = dp[s][2] = 1; } for(int i = (1 << n - 1) - 1; i >= 1; i--){ for(int j = 0; j < 4; j++){ for(int k = 0; k < 4; k++){ dp[i][j | k] = max(dp[i][j | k], dp[2 * i][j] + dp[2 * i + 1][k] + (j | k)); } } } cout << max({dp[1][1], dp[1][2], dp[1][3]}) + 1 << '\n'; }"
"B. WeirdSort
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
You are given an array $$$a$$$ of length $$$n$$$.
You are also given a set of 
distinct
 positions $$$p_1, p_2, \dots, p_m$$$, where $$$1 \le p_i < n$$$. The position $$$p_i$$$ means that you can swap elements $$$a[p_i]$$$ and $$$a[p_i + 1]$$$. You can apply this operation any number of times for each of the given 
positions
.
Your task is to determine if it is possible to sort the initial array in non-decreasing order ($$$a_1 \le a_2 \le \dots \le a_n$$$) using only allowed swaps.
For example, if $$$a = [3, 2, 1]$$$ and $$$p = [1, 2]$$$, then we can first swap elements $$$a[2]$$$ and $$$a[3]$$$ (because position $$$2$$$ is contained in the given set $$$p$$$). We get the array $$$a = [3, 1, 2]$$$. Then we swap $$$a[1]$$$ and $$$a[2]$$$ (position $$$1$$$ is also contained in $$$p$$$). We get the array $$$a = [1, 3, 2]$$$. Finally, we swap $$$a[2]$$$ and $$$a[3]$$$ again and get the array $$$a = [1, 2, 3]$$$, sorted in non-decreasing order.
You can see that if $$$a = [4, 1, 2, 3]$$$ and $$$p = [3, 2]$$$ then you cannot sort the array.
You have to answer $$$t$$$ independent test cases.
Input
The first line of the input contains one integer $$$t$$$ ($$$1 \le t \le 100$$$) — the number of test cases.
Then $$$t$$$ test cases follow. The first line of each test case contains two integers $$$n$$$ and $$$m$$$ ($$$1 \le m < n \le 100$$$) — the number of elements in $$$a$$$ and the number of elements in $$$p$$$. The second line of the test case contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$). The third line of the test case contains $$$m$$$ integers $$$p_1, p_2, \dots, p_m$$$ ($$$1 \le p_i < n$$$, all $$$p_i$$$ are distinct) — the set of positions described in the problem statement.
Output
For each test case, print the answer — ""
YES
"" (without quotes) if you can sort the initial array in non-decreasing order ($$$a_1 \le a_2 \le \dots \le a_n$$$) using only allowed swaps. Otherwise, print ""
NO
"".
Example
Input

6
3 2
3 2 1
1 2
4 2
4 1 2 3
3 2
5 1
1 2 3 4 5
1
4 2
2 1 4 3
1 3
4 2
4 3 2 1
1 3
5 2
2 1 2 3 3
1 4

Output

YES
NO
YES
YES
NO
YES","#include<bits/stdc++.h> #define endl '\n' using namespace std; typedef long long i64; typedef int i32; typedef long double ld; void like(void) { int n,m; cin>>n>>m; int a[n+2]; map<int,int> mp; int i,j; for(i=1;i<=n;i++) cin>>a[i]; while(m--) { int x; cin>>x; mp[x]++; } for(i=1;i<=n;i++) for(j=n;j>1;j--) if(a[j]<a[j-1]&&mp[j-1]==0) { cout<<""NO""<<endl; return ; } else if(a[j]<a[j-1])swap(a[j],a[j-1]); cout<<""YES""<<endl; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int t; cin>>t; while(t--) like(); return 0; }"
"B. Bogosort
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
You are given an array $$$a_1, a_2, \dots , a_n$$$. Array is good if for each pair of indexes $$$i < j$$$ the condition $$$j - a_j \ne i - a_i$$$ holds. Can you shuffle this array so that it becomes good? To shuffle an array means to reorder its elements arbitrarily (leaving the initial order is also an option).
For example, if $$$a = [1, 1, 3, 5]$$$, then shuffled arrays $$$[1, 3, 5, 1]$$$, $$$[3, 5, 1, 1]$$$ and $$$[5, 3, 1, 1]$$$ are good, but shuffled arrays $$$[3, 1, 5, 1]$$$, $$$[1, 1, 3, 5]$$$ and $$$[1, 1, 5, 3]$$$ aren't.
It's guaranteed that it's always possible to shuffle an array to meet this condition.
Input
The first line contains one integer $$$t$$$ ($$$1 \le t \le 100$$$) — the number of test cases.
The first line of each test case contains one integer $$$n$$$ ($$$1 \le n \le 100$$$) — the length of array $$$a$$$.
The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \dots , a_n$$$ ($$$1 \le a_i \le 100$$$).
Output
For each test case print the shuffled version of the array $$$a$$$ which is good.
Example
Input

3
1
7
4
1 1 3 5
6
3 2 1 5 6 4

Output

7
1 5 1 3
2 4 6 1 3 5","#include <bits/stdc++.h> using namespace std; int main() { int t; cin >> t; while (t--) { int n; cin>>n; int a[n]; for (int i = 0; i < n; i++) { /* code */ cin>>a[i]; } sort(a,a+n,greater<int>()); for (int i = 0; i < n; i++) { /* code */ cout<<a[i]<<"" ""; } cout<<""\n""; } }"
"B. Bogosort
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
You are given an array $$$a_1, a_2, \dots , a_n$$$. Array is good if for each pair of indexes $$$i < j$$$ the condition $$$j - a_j \ne i - a_i$$$ holds. Can you shuffle this array so that it becomes good? To shuffle an array means to reorder its elements arbitrarily (leaving the initial order is also an option).
For example, if $$$a = [1, 1, 3, 5]$$$, then shuffled arrays $$$[1, 3, 5, 1]$$$, $$$[3, 5, 1, 1]$$$ and $$$[5, 3, 1, 1]$$$ are good, but shuffled arrays $$$[3, 1, 5, 1]$$$, $$$[1, 1, 3, 5]$$$ and $$$[1, 1, 5, 3]$$$ aren't.
It's guaranteed that it's always possible to shuffle an array to meet this condition.
Input
The first line contains one integer $$$t$$$ ($$$1 \le t \le 100$$$) — the number of test cases.
The first line of each test case contains one integer $$$n$$$ ($$$1 \le n \le 100$$$) — the length of array $$$a$$$.
The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \dots , a_n$$$ ($$$1 \le a_i \le 100$$$).
Output
For each test case print the shuffled version of the array $$$a$$$ which is good.
Example
Input

3
1
7
4
1 1 3 5
6
3 2 1 5 6 4

Output

7
1 5 1 3
2 4 6 1 3 5","#include <bits/stdc++.h> using namespace std; int main() { int t; cin >> t; while (t--) { int n; cin>>n; int a[n]; for (int i = 0; i < n; i++) { /* code */ cin>>a[i]; } sort(a,a+n,greater<int>()); for (int i = 0; i < n; i++) { /* code */ cout<<a[i]<<"" ""; } cout<<""\n""; } }"
"B. Different Rules
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
Nikolay has only recently started in competitive programming, but already qualified to the finals of one prestigious olympiad. There going to be $$$n$$$ participants, one of whom is Nikolay. Like any good olympiad, it consists of two rounds. Tired of the traditional rules, in which the participant who solved the largest number of problems wins, the organizers came up with different rules.
Suppose in the first round participant A took $$$x$$$-th place and in the second round — $$$y$$$-th place. Then the total score of the participant A is sum $$$x + y$$$. The overall place of the participant A is the number of participants (including A) having their total score less than or equal to the total score of A. Note, that some participants may end up having a common overall place. It is also important to note, that in both the first and the second round there were no two participants tying at a common place. In other words, for every $$$i$$$ from $$$1$$$ to $$$n$$$ 
exactly one
 participant took $$$i$$$-th place in first round and 
exactly one
 participant took $$$i$$$-th place in second round.
Right after the end of the Olympiad, Nikolay was informed that he got $$$x$$$-th place in first round and $$$y$$$-th place in the second round. Nikolay doesn't know the results of other participants, yet he wonders what is the minimum and maximum place he can take, if we consider the most favorable and unfavorable outcome for him. Please help Nikolay to find the answer to this question.
Input
The first line contains an integer $$$t$$$ ($$$1 \le t \le 100$$$) — the number of test cases to solve.
Each of the following $$$t$$$ lines contains integers $$$n$$$, $$$x$$$, $$$y$$$ ($$$1 \leq n \leq 10^9$$$, $$$1 \le x, y \le n$$$) — the number of participants in the olympiad, the place that Nikolay took in the first round and the place that Nikolay took in the second round.
Output
Print two integers — the minimum and maximum possible overall place Nikolay could take.
Examples
Input
1
5 1 3
Output
1 3
Input
1
6 3 4
Output
2 6
Note
Explanation for the first example:
Suppose there were 5 participants A-E. Let's denote Nikolay as A. The the most favorable results for Nikolay could look as follows:
 
 
However, the results of the Olympiad could also look like this:
 
 
In the first case Nikolay would have taken first place, and in the second — third place.","#include<bits/stdc++.h> #define x first #define y second #define all(v) v.begin(),v.end() using namespace std; typedef long long LL; typedef pair<int,int> pii; void solve() { int n,a,b; cin>>n>>a>>b; int mi = a + b - n + 1,mx = a + b - 1; if(mi <= 0) mi = 1; if(mi > n) mi = n; if(mx > n) mx = n; cout<<mi<<' '<<mx<<'\n'; } int main() { ios::sync_with_stdio(false); cin.tie(0);cout.tie(0); int tc = 1; cin>>tc; while (tc--) { solve(); } return 0; }"
"B. Double Elimination
time limit per test
2 seconds
memory limit per test
512 megabytes
input
standard input
output
standard output
The biggest event of the year – Cota 2 world championship ""The Innernational"" is right around the corner. $$$2^n$$$ teams will compete in a double-elimination format (please, carefully read problem statement even if you know what is it) to identify the champion. 
Teams are numbered from $$$1$$$ to $$$2^n$$$ and will play games one-on-one. All teams start in the upper bracket.
All upper bracket matches will be held played between teams that haven't lost any games yet. Teams are split into games by team numbers. Game winner advances in the next round of upper bracket, losers drop into the lower bracket.
Lower bracket starts with $$$2^{n-1}$$$ teams that lost the first upper bracket game. Each lower bracket round consists of two games. In the first game of a round $$$2^k$$$ teams play a game with each other (teams are split into games by team numbers). $$$2^{k-1}$$$ loosing teams are eliminated from the championship, $$$2^{k-1}$$$ winning teams are playing $$$2^{k-1}$$$ teams that got eliminated in this round of upper bracket (again, teams are split into games by team numbers). As a result of each round both upper and lower bracket have $$$2^{k-1}$$$ teams remaining. See example notes for better understanding.
Single remaining team of upper bracket plays with single remaining team of lower bracket in grand-finals to identify championship winner.
You are a fan of teams with numbers $$$a_1, a_2, ..., a_k$$$. You want the championship to have as many games with your favourite teams as possible. Luckily, you can affect results of every championship game the way you want. What's maximal possible number of championship games that include teams you're fan of?
Input
First input line has two integers $$$n, k$$$ — $$$2^n$$$ teams are competing in the championship. You are a fan of $$$k$$$ teams ($$$2 \le n \le 17; 0 \le k \le 2^n$$$).
Second input line has $$$k$$$ distinct integers $$$a_1, \ldots, a_k$$$ — numbers of teams you're a fan of ($$$1 \le a_i \le 2^n$$$).
Output
Output single integer — maximal possible number of championship games that include teams you're fan of.
Examples
Input

3 1
6

Output

6

Input

3 3
1 7 8

Output

11

Input

3 4
1 3 5 7

Output

14

Note
On the image, each game of the championship is denoted with an English letter ($$$a$$$ to $$$n$$$). Winner of game $$$i$$$ is denoted as $$$Wi$$$, loser is denoted as $$$Li$$$. Teams you're a fan of are highlighted with red background.
In the first example, team $$$6$$$ will play in 6 games if it looses the first upper bracket game (game $$$c$$$) and wins all lower bracket games (games $$$h, j, l, m$$$). 
In the second example, teams $$$7$$$ and $$$8$$$ have to play with each other in the first game of upper bracket (game $$$d$$$). Team $$$8$$$ can win all remaining games in upper bracket, when teams $$$1$$$ and $$$7$$$ will compete in the lower bracket. 
In the third example, your favourite teams can play in all games of the championship.","#include <bits/stdc++.h> #define maxn 4000086 using namespace std; int n, k; int a[maxn], x; int f[maxn][4]; #define ls(x) (x << 1) #define rs(x) (x << 1 | 1) void solve(int x, int l, int r){ if(l + 1 == r){ f[x][a[l] | (a[r] << 1)] = f[x][a[r] | (a[l] << 1)] = a[l] | a[r]; return; } int mid = l + r >> 1; solve(ls(x), l, mid), solve(rs(x), mid + 1, r); for(int a = 0;a < 4;a++){ for(int b = 0;b < 4;b++){ for(int i = 0;i <= 1;i++){ for(int j = 0;j <= 1;j++){ for(int k = 0;k <= 1;k++){ int cnt = f[ls(x)][a] + f[rs(x)][b]; cnt += (a & 1) | (b & 1); cnt += ((a >> 1) & 1) | ((b >> 1) & 1); cnt += (i ? b & 1 : a & 1) | (j ? (a >> 1) & 1 : (b >> 1) & 1); int c = (i ? a & 1 : b & 1) | ((k ? (i ? b & 1 : a & 1) : (j ? (a >> 1) & 1 : (b >> 1) & 1)) << 1); f[x][c] = max(f[x][c], cnt); } } } } } } int main(){ scanf(""%d%d"", &n, &k); while(k--) scanf(""%d"", &x), a[x] = 1; memset(f, -0x3f, sizeof(f)); solve(1, 1, 1 << n); printf(""%d"", max({f[1][0], f[1][1] + 1, f[1][2] + 1, f[1][3] + 1})); }"
"B. Homecoming
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
After a long party Petya decided to return home, but he turned out to be at the opposite end of the town from his home. There are $$$n$$$ crossroads in the line in the town, and there is either the bus or the tram station at each crossroad.
The crossroads are represented as a string $$$s$$$ of length $$$n$$$, where $$$s_i = \texttt{A}$$$, if there is a bus station at $$$i$$$-th crossroad, and $$$s_i = \texttt{B}$$$, if there is a tram station at $$$i$$$-th crossroad. Currently Petya is at the first crossroad (which corresponds to $$$s_1$$$) and his goal is to get to the last crossroad (which corresponds to $$$s_n$$$).
If for two crossroads $$$i$$$ and $$$j$$$ for all crossroads $$$i, i+1, \ldots, j-1$$$ there is a bus station, one can pay $$$a$$$ roubles for the bus ticket, and go from $$$i$$$-th crossroad to the $$$j$$$-th crossroad by the bus (it is not necessary to have a bus station at the $$$j$$$-th crossroad). Formally, paying $$$a$$$ roubles Petya can go from $$$i$$$ to $$$j$$$ if $$$s_t = \texttt{A}$$$ for all $$$i \le t < j$$$. 
If for two crossroads $$$i$$$ and $$$j$$$ for all crossroads $$$i, i+1, \ldots, j-1$$$ there is a tram station, one can pay $$$b$$$ roubles for the tram ticket, and go from $$$i$$$-th crossroad to the $$$j$$$-th crossroad by the tram (it is not necessary to have a tram station at the $$$j$$$-th crossroad). Formally, paying $$$b$$$ roubles Petya can go from $$$i$$$ to $$$j$$$ if $$$s_t = \texttt{B}$$$ for all $$$i \le t < j$$$.
For example, if $$$s$$$=""
AABBBAB
"", $$$a=4$$$ and $$$b=3$$$ then Petya needs:
 
 buy one bus ticket to get from $$$1$$$ to $$$3$$$, 
 buy one tram ticket to get from $$$3$$$ to $$$6$$$, 
 buy one bus ticket to get from $$$6$$$ to $$$7$$$. 
Thus, in total he needs to spend $$$4+3+4=11$$$ roubles. Please note that the type of the stop at the last crossroad (i.e. the character $$$s_n$$$) does not affect the final expense.
Now Petya is at the first crossroad, and he wants to get to the $$$n$$$-th crossroad. After the party he has left with $$$p$$$ roubles. He's decided to go to some station on foot, and then go to home using only public transport.
Help him to choose the closest crossroad $$$i$$$ to go on foot the first, so he has enough money to get from the $$$i$$$-th crossroad to the $$$n$$$-th, using only tram and bus tickets.
Input
Each test contains one or more test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \le t \le 10^4$$$).
The first line of each test case consists of three integers $$$a, b, p$$$ ($$$1 \le a, b, p \le 10^5$$$) — the cost of bus ticket, the cost of tram ticket and the amount of money Petya has.
The second line of each test case consists of one string $$$s$$$, where $$$s_i = \texttt{A}$$$, if there is a bus station at $$$i$$$-th crossroad, and $$$s_i = \texttt{B}$$$, if there is a tram station at $$$i$$$-th crossroad ($$$2 \le |s| \le 10^5$$$).
It is guaranteed, that the sum of the length of strings $$$s$$$ by all test cases in one test doesn't exceed $$$10^5$$$.
Output
For each test case print one number — the minimal index $$$i$$$ of a crossroad Petya should go on foot. The rest of the path (i.e. from $$$i$$$ to $$$n$$$ he should use public transport).
Example
Input

5
2 2 1
BB
1 1 1
AB
3 2 8
AABBBBAABB
5 3 4
BBBBB
2 1 1
ABABAB

Output

2
1
3
1
6","#include <iostream> #include <vector> #include <algorithm> #include <bits/stdc++.h> #include <iterator> #include <map> using namespace std; bool sortbysec(const pair<char,int> &a, const pair<char,int> &b) { return (a.first > b.first); } bool isPalindrome(string S) { // Stores the reverse of the // string S string P = S; // Reverse the string P reverse(P.begin(), P.end()); // If S is equal to P if (S == P) { // Return ""Yes"" return true; } // Otherwise else { // return ""No"" return false; } } bool poss(vector<int> &g1,vector<int> &g2,long long int mid){ long long int sum=0; int j=0; while(j<g1.size()){ if(g1[j]>mid){ sum=sum+g2[j]; } j++; } if(sum<=mid){ return true; } return false; } bool isPrime(long long int n) { if (n <= 1) return false; for (long long int i = 2; i <= sqrt(n); i++) if (n % i == 0) return false; return true; } long long int onesComplement(long long int n) { vector<int> v; // convert to binary representation while (n != 0) { v.push_back(n % 2); n = n / 2; } reverse(v.begin(), v.end()); // change 1's to 0 and 0's to 1 for (int i = 0; i < v.size(); i++) { if (v[i] == 0) v[i] = 1; else v[i] = 0; } // convert back to number representation int two = 1; for (int i = v.size() - 1; i >= 0; i--) { n = n + v[i] * two; two = two * 2; } return n; } static bool sortbysec(const vector<int> &a, const vector<int> &b) { return (a.size() < b.size()); } bool ans23(int n,vector<pair<int,int>> g1){ int j=0; while(j<g1.size()){ if(n<g1[j].first){ return false; } else{ n=n+g1[j].second; } j++; } return true; } int ans(int i,int n,vector<int> &dp,string s, map<char,vector<int>> m1,map<char,int> m2){ if(i>=n){ return 0; } if(dp[i]!=-1){ return dp[i]; } int r=m1[s[i]].size(); if(m2[s[i]]<r){ m2[s[i]]++; int r1=(ans(i+1,n,dp,s,m1,m2)); int r2=2+ans(m1[s[i]][m2[s[i]]-1]+1,n,dp,s,m1,m2); return dp[i]=max(r1,r2); } else{ return dp[i]=ans(i+1,n,dp,s,m1,m2); } } int main(){ int t; cin>>t; int i=0; while(i<t){ int a,b,p; cin>>a>>b>>p; string s; cin>>s; int j=s.length()-2; while(1){ if(s[j]=='B'){ if(p>=b){ while(s[j]=='B'&&j>=0){ j--; } p=p-b; } else{ break; } } if(s[j]=='A'){ if(p>=a){ while(s[j]=='A'&&j>=0){ j--; } p=p-a; } else{ break; } } if(j<0){ break; } } if(j<0){ cout<<1<<""\n""; i++; continue; } if(j>=s.length()-2){ cout<<s.length()<<""\n""; i++; continue; } cout<<j+2<<""\n""; i++; } return 0; }"
"B. String Modification
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
Vasya has a string $$$s$$$ of length $$$n$$$. He decides to make the following modification to the string: 
 
 Pick an integer $$$k$$$, ($$$1 \leq k \leq n$$$). 
 For $$$i$$$ from $$$1$$$ to $$$n-k+1$$$, reverse the substring $$$s[i:i+k-1]$$$ of $$$s$$$. For example, if string $$$s$$$ is 
qwer
 and $$$k = 2$$$, below is the series of transformations the string goes through: 
 
 
qwer
 (original string) 
 
wqer
 (after reversing the first substring of length $$$2$$$) 
 
weqr
 (after reversing the second substring of length $$$2$$$) 
 
werq
 (after reversing the last substring of length $$$2$$$) 
 Hence, the resulting string after modifying $$$s$$$ with $$$k = 2$$$ is 
werq
. 
Vasya wants to choose a $$$k$$$ such that the string obtained after the above-mentioned modification is lexicographically smallest possible among all choices of $$$k$$$. Among all such $$$k$$$, he wants to choose the smallest one. Since he is busy attending Felicity 2020, he asks for your help.
A string $$$a$$$ is lexicographically smaller than a string $$$b$$$ if and only if one of the following holds: 
 
 $$$a$$$ is a prefix of $$$b$$$, but $$$a \ne b$$$; 
 in the first position where $$$a$$$ and $$$b$$$ differ, the string $$$a$$$ has a letter that appears earlier in the alphabet than the corresponding letter in $$$b$$$. 
Input
Each test contains multiple test cases. 
The first line contains the number of test cases $$$t$$$ ($$$1 \le t \le 5000$$$). The description of the test cases follows.
The first line of each test case contains a single integer $$$n$$$ ($$$1 \le n \le 5000$$$) — the length of the string $$$s$$$.
The second line of each test case contains the string $$$s$$$ of $$$n$$$ lowercase latin letters.
It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$5000$$$.
Output
For each testcase output two lines:
In the first line output the lexicographically smallest string $$$s'$$$ achievable after the above-mentioned modification. 
In the second line output the appropriate value of $$$k$$$ ($$$1 \leq k \leq n$$$) that you chose for performing the modification. If there are multiple values of $$$k$$$ that give the lexicographically smallest string, output the smallest value of $$$k$$$ among them.
Example
Input

6
4
abab
6
qwerty
5
aaaaa
6
alaska
9
lfpbavjsm
1
p

Output

abab
1
ertyqw
3
aaaaa
1
aksala
6
avjsmbpfl
5
p
1

Note
In the first testcase of the first sample, the string modification results for the sample 
abab
 are as follows : 
 
 for $$$k = 1$$$ : 
abab
 
 for $$$k = 2$$$ : 
baba
 
 for $$$k = 3$$$ : 
abab
 
 for $$$k = 4$$$ : 
baba
The lexicographically smallest string achievable through modification is 
abab
 for $$$k = 1$$$ and $$$3$$$. Smallest value of $$$k$$$ needed to achieve is hence $$$1$$$.","#include<iostream> #include<cstring> #include<vector> #include<map> #include<queue> #include<unordered_map> #include<cmath> #include<cstdio> #include<algorithm> #include<set> #include<cstdlib> #include<stack> #include<ctime> #define forin(i,a,n) for(int i=a;i<=n;i++) #define forni(i,n,a) for(int i=n;i>=a;i--) #define fi first #define se second using namespace std; typedef long long ll; typedef double db; typedef pair<int,int> PII; const double eps=1e-7; const int N=6e5+7 ,M=2*N , INF=0x3f3f3f3f,mod=1e9+7; inline ll read() {ll x=0,f=1;char c=getchar();while(c<'0'||c>'9') {if(c=='-') f=-1;c=getchar();} while(c>='0'&&c<='9') {x=(ll)x*10+c-'0';c=getchar();} return x*f;} void stin() {freopen(""in_put.txt"",""r"",stdin);freopen(""my_out_put.txt"",""w"",stdout);} template<typename T> T gcd(T a,T b) {return b==0?a:gcd(b,a%b);} template<typename T> T lcm(T a,T b) {return a*b/gcd(a,b);} int T; int n,m,k; string str; void solve() { n=read(); cin>>str; int id=1; string ans=str; for(int i=2;i<=n;i++) { if((n-i+1)%2==1) { string p=str.substr(0,i-1); reverse(p.begin(),p.end()); string k=str.substr(i-1,n-i+1)+p; if(ans>k) { ans=k; id=i; } }else { string k=str.substr(i-1,n-i+1)+str.substr(0,i-1); if(ans>k) { ans=k; id=i; } } } cout<<ans<<'\n'<<id<<'\n'; } int main() { // init(); // stin(); scanf(""%d"",&T); // T=1; while(T--) solve(); return 0; } "
"B. Journey Planning
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
Tanya wants to go on a journey across the cities of Berland. There are $$$n$$$ cities situated along the main railroad line of Berland, and these cities are numbered from $$$1$$$ to $$$n$$$. 
Tanya plans her journey as follows. First of all, she will choose some city $$$c_1$$$ to start her journey. She will visit it, and after that go to some other city $$$c_2 > c_1$$$, then to some other city $$$c_3 > c_2$$$, and so on, until she chooses to end her journey in some city $$$c_k > c_{k - 1}$$$. So, the sequence of visited cities $$$[c_1, c_2, \dots, c_k]$$$ should be strictly increasing.
There are some additional constraints on the sequence of cities Tanya visits. Each city $$$i$$$ has a beauty value $$$b_i$$$ associated with it. If there is only one city in Tanya's journey, these beauty values imply no additional constraints. But if there are multiple cities in the sequence, then for any pair of adjacent cities $$$c_i$$$ and $$$c_{i + 1}$$$, the condition $$$c_{i + 1} - c_i = b_{c_{i + 1}} - b_{c_i}$$$ must hold.
For example, if $$$n = 8$$$ and $$$b = [3, 4, 4, 6, 6, 7, 8, 9]$$$, there are several three possible ways to plan a journey:
 
 $$$c = [1, 2, 4]$$$; 
 $$$c = [3, 5, 6, 8]$$$; 
 $$$c = [7]$$$ (a journey consisting of one city is also valid). 
There are some additional ways to plan a journey that are not listed above.
Tanya wants her journey to be as beautiful as possible. The beauty value of the whole journey is the sum of beauty values over all visited cities. Can you help her to choose the optimal plan, that is, to maximize the beauty value of the journey?
Input
The first line contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of cities in Berland.
The second line contains $$$n$$$ integers $$$b_1$$$, $$$b_2$$$, ..., $$$b_n$$$ ($$$1 \le b_i \le 4 \cdot 10^5$$$), where $$$b_i$$$ is the beauty value of the $$$i$$$-th city.
Output
Print one integer — the maximum beauty of a journey Tanya can choose.
Examples
Input

6
10 7 1 9 10 15

Output

26

Input

1
400000

Output

400000

Input

7
8 9 26 11 12 29 14

Output

55

Note
The optimal journey plan in the first example is $$$c = [2, 4, 5]$$$.
The optimal journey plan in the second example is $$$c = [1]$$$.
The optimal journey plan in the third example is $$$c = [3, 6]$$$.","#include <bits/stdc++.h> #define forn(i, n) for (int i = 0; i < (int)(n); i++) // #define _GLIBCXX_DEBUG #define int int64_t using namespace std; signed main() { iostream::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int n; cin >> n; vector<int> a(n); map<int,int> q; forn(i, n) { cin >> a[i]; q[i - a[i]] += a[i]; } int ans = 0; for (auto[x,y] : q) { ans = max(ans, y); } cout << ans; return 0; }"
"B. Navigation System
time limit per test
2 seconds
memory limit per test
512 megabytes
input
standard input
output
standard output
The map of Bertown can be represented as a set of $$$n$$$ intersections, numbered from $$$1$$$ to $$$n$$$ and connected by $$$m$$$ one-way roads. It is possible to move along the roads from any intersection to any other intersection. The length of some path from one intersection to another is the number of roads that one has to traverse along the path. The shortest path from one intersection $$$v$$$ to another intersection $$$u$$$ is the path that starts in $$$v$$$, ends in $$$u$$$ and has the minimum length among all such paths.
Polycarp lives near the intersection $$$s$$$ and works in a building near the intersection $$$t$$$. Every day he gets from $$$s$$$ to $$$t$$$ by car. Today he has chosen the following path to his workplace: $$$p_1$$$, $$$p_2$$$, ..., $$$p_k$$$, where $$$p_1 = s$$$, $$$p_k = t$$$, and all other elements of this sequence are the intermediate intersections, listed in the order Polycarp arrived at them. Polycarp never arrived at the same intersection twice, so all elements of this sequence are pairwise distinct. 
Note that you know Polycarp's path beforehand (it is fixed), and it is not necessarily one of the shortest paths from $$$s$$$ to $$$t$$$
.
Polycarp's car has a complex navigation system installed in it. Let's describe how it works. When Polycarp starts his journey at the intersection $$$s$$$, the system chooses some shortest path from $$$s$$$ to $$$t$$$ and shows it to Polycarp. Let's denote the next intersection in the chosen path as $$$v$$$. If Polycarp chooses to drive along the road from $$$s$$$ to $$$v$$$, then the navigator shows him the same shortest path (obviously, starting from $$$v$$$ as soon as he arrives at this intersection). However, if Polycarp chooses to drive to another intersection $$$w$$$ instead, the navigator 
rebuilds
 the path: as soon as Polycarp arrives at $$$w$$$, the navigation system chooses some shortest path from $$$w$$$ to $$$t$$$ and shows it to Polycarp. The same process continues until Polycarp arrives at $$$t$$$: if Polycarp moves along the road recommended by the system, it maintains the shortest path it has already built; but if Polycarp chooses some other path, the system 
rebuilds
 the path by the same rules.
Here is an example. Suppose the map of Bertown looks as follows, and Polycarp drives along the path $$$[1, 2, 3, 4]$$$ ($$$s = 1$$$, $$$t = 4$$$): 
Check the picture by the link 
http://tk.codeforces.com/a.png
 
 
 When Polycarp starts at $$$1$$$, the system chooses some shortest path from $$$1$$$ to $$$4$$$. There is only one such path, it is $$$[1, 5, 4]$$$; 
 Polycarp chooses to drive to $$$2$$$, which is not along the path chosen by the system. When Polycarp arrives at $$$2$$$, the navigator 
rebuilds
 the path by choosing some shortest path from $$$2$$$ to $$$4$$$, for example, $$$[2, 6, 4]$$$ (note that it could choose $$$[2, 3, 4]$$$); 
 Polycarp chooses to drive to $$$3$$$, which is not along the path chosen by the system. When Polycarp arrives at $$$3$$$, the navigator 
rebuilds
 the path by choosing the only shortest path from $$$3$$$ to $$$4$$$, which is $$$[3, 4]$$$; 
 Polycarp arrives at $$$4$$$ along the road chosen by the navigator, so the system does not have to rebuild anything. 
Overall, we get $$$2$$$ rebuilds in this scenario. Note that if the system chose $$$[2, 3, 4]$$$ instead of $$$[2, 6, 4]$$$ during the second step, there would be only $$$1$$$ rebuild (since Polycarp goes along the path, so the system maintains the path $$$[3, 4]$$$ during the third step).
The example shows us that the number of rebuilds can differ even if the map of Bertown and the path chosen by Polycarp stays the same. Given this information (the map and Polycarp's path), can you determine the minimum and the maximum number of rebuilds that could have happened during the journey?
Input
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$2 \le n \le m \le 2 \cdot 10^5$$$) — the number of intersections and one-way roads in Bertown, respectively.
Then $$$m$$$ lines follow, each describing a road. Each line contains two integers $$$u$$$ and $$$v$$$ ($$$1 \le u, v \le n$$$, $$$u \ne v$$$) denoting a road from intersection $$$u$$$ to intersection $$$v$$$. All roads in Bertown are pairwise distinct, which means that each ordered pair $$$(u, v)$$$ appears at most once in these $$$m$$$ lines (but if there is a road $$$(u, v)$$$, the road $$$(v, u)$$$ can also appear).
The following line contains one integer $$$k$$$ ($$$2 \le k \le n$$$) — the number of intersections in Polycarp's path from home to his workplace.
The last line contains $$$k$$$ integers $$$p_1$$$, $$$p_2$$$, ..., $$$p_k$$$ ($$$1 \le p_i \le n$$$, all these integers are pairwise distinct) — the intersections along Polycarp's path in the order he arrived at them. $$$p_1$$$ is the intersection where Polycarp lives ($$$s = p_1$$$), and $$$p_k$$$ is the intersection where Polycarp's workplace is situated ($$$t = p_k$$$). It is guaranteed that for every $$$i \in [1, k - 1]$$$ the road from $$$p_i$$$ to $$$p_{i + 1}$$$ exists, so the path goes along the roads of Bertown. 
Output
Print two integers: the minimum and the maximum number of 
rebuilds
 that could have happened during the journey.
Examples
Input

6 9
1 5
5 4
1 2
2 3
3 4
4 1
2 6
6 4
4 2
4
1 2 3 4

Output

1 2

Input

7 7
1 2
2 3
3 4
4 5
5 6
6 7
7 1
7
1 2 3 4 5 6 7

Output

0 0

Input

8 13
8 7
8 6
7 5
7 4
6 5
6 4
5 3
5 2
4 3
4 2
3 1
2 1
1 8
5
8 7 5 2 1

Output

0 3","#include <bits/stdc++.h> using namespace std; #define MAX (int) 2e5 #define INF INT_MAX int distanceTo[MAX]; map<int, vector<int>> bertown1; map<int, vector<int>> bertown2; void BFS(int source) { int parent; set<int> visited; queue<int> toVisit; toVisit.push(source); visited.insert(source); while(!toVisit.empty()) { parent = toVisit.front(); for(int child : bertown2[parent]) { if(visited.count(child) == 0) { distanceTo[child] = distanceTo[parent] + 1; toVisit.push(child); visited.insert(child); } } toVisit.pop(); } } int main() { int n; int m; int a; int b; int k; int p; cin >> n; cin >> m; for(int i = 0; i < m; i++) { cin >> a; cin >> b; a--; b--; bertown1[a].push_back(b); bertown2[b].push_back(a); } int minCount = 0; int maxCount = 0; vector<int> actions; cin >> k; for(int i = 0; i < k; i++) { cin >> p; actions.push_back(--p); } BFS(actions[k - 1]); int prev; int curr; for(int i = 1; i < k; i++) { prev = actions[i - 1]; curr = actions[i]; if(distanceTo[curr] >= distanceTo[prev]) { minCount++; maxCount++; } else { for(int child : bertown1[prev]) { if((child != curr) && (distanceTo[child] == distanceTo[curr])) { maxCount++; break; } } } } cout << minCount << "" "" << maxCount << ""\n""; }"
"B. Journey Planning
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
Tanya wants to go on a journey across the cities of Berland. There are $$$n$$$ cities situated along the main railroad line of Berland, and these cities are numbered from $$$1$$$ to $$$n$$$. 
Tanya plans her journey as follows. First of all, she will choose some city $$$c_1$$$ to start her journey. She will visit it, and after that go to some other city $$$c_2 > c_1$$$, then to some other city $$$c_3 > c_2$$$, and so on, until she chooses to end her journey in some city $$$c_k > c_{k - 1}$$$. So, the sequence of visited cities $$$[c_1, c_2, \dots, c_k]$$$ should be strictly increasing.
There are some additional constraints on the sequence of cities Tanya visits. Each city $$$i$$$ has a beauty value $$$b_i$$$ associated with it. If there is only one city in Tanya's journey, these beauty values imply no additional constraints. But if there are multiple cities in the sequence, then for any pair of adjacent cities $$$c_i$$$ and $$$c_{i + 1}$$$, the condition $$$c_{i + 1} - c_i = b_{c_{i + 1}} - b_{c_i}$$$ must hold.
For example, if $$$n = 8$$$ and $$$b = [3, 4, 4, 6, 6, 7, 8, 9]$$$, there are several three possible ways to plan a journey:
 
 $$$c = [1, 2, 4]$$$; 
 $$$c = [3, 5, 6, 8]$$$; 
 $$$c = [7]$$$ (a journey consisting of one city is also valid). 
There are some additional ways to plan a journey that are not listed above.
Tanya wants her journey to be as beautiful as possible. The beauty value of the whole journey is the sum of beauty values over all visited cities. Can you help her to choose the optimal plan, that is, to maximize the beauty value of the journey?
Input
The first line contains one integer $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — the number of cities in Berland.
The second line contains $$$n$$$ integers $$$b_1$$$, $$$b_2$$$, ..., $$$b_n$$$ ($$$1 \le b_i \le 4 \cdot 10^5$$$), where $$$b_i$$$ is the beauty value of the $$$i$$$-th city.
Output
Print one integer — the maximum beauty of a journey Tanya can choose.
Examples
Input

6
10 7 1 9 10 15

Output

26

Input

1
400000

Output

400000

Input

7
8 9 26 11 12 29 14

Output

55

Note
The optimal journey plan in the first example is $$$c = [2, 4, 5]$$$.
The optimal journey plan in the second example is $$$c = [1]$$$.
The optimal journey plan in the third example is $$$c = [3, 6]$$$.","#include<bits/stdc++.h> using namespace std; typedef long long ll; typedef pair<ll,ll> pll; const ll N=1e6+5; const ll mod=1e9+7; const ll inf=1e18; #define endl ""\n"" ll a[N],b[N],p,q,dp[N]; ll ans; unordered_map<ll,ll> vis; signed main(){ ios::sync_with_stdio(false); cin.tie(0);cout.tie(0); ll n;cin>>n; for(ll i=1;i<=n;i++) cin>>a[i]; for(ll i=1;i<=n;i++){ vis[a[i]-i]+=a[i]; ans=max(ans,vis[a[i]-i]); } cout<<ans; } "
"B. Present
time limit per test
3 seconds
memory limit per test
512 megabytes
input
standard input
output
standard output
Catherine received an array of integers as a gift for March 8. Eventually she grew bored with it, and she started calculated various useless characteristics for it. She succeeded to do it for each one she came up with. But when she came up with another one — 
xor
 of all pairwise sums of elements in the array, she realized that she couldn't compute it for a very large array, thus she asked for your help. Can you do it? Formally, you need to compute
$$$$$$ (a_1 + a_2) \oplus (a_1 + a_3) \oplus \ldots \oplus (a_1 + a_n) \\ \oplus (a_2 + a_3) \oplus \ldots \oplus (a_2 + a_n) \\ \ldots \\ \oplus (a_{n-1} + a_n) \\ $$$$$$
Here $$$x \oplus y$$$ is a bitwise XOR operation (i.e. $$$x$$$ 
^
 $$$y$$$ in many modern programming languages). You can read about it in Wikipedia: 
https://en.wikipedia.org/wiki/Exclusive_or#Bitwise_operation
.
Input
The first line contains a single integer $$$n$$$ ($$$2 \leq n \leq 400\,000$$$) — the number of integers in the array.
The second line contains integers $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \leq a_i \leq 10^7$$$).
Output
Print a single integer — xor of all pairwise sums of integers in the given array.
Examples
Input

2
1 2

Output

3
Input

3
1 2 3

Output

2
Note
In the first sample case there is only one sum $$$1 + 2 = 3$$$.
In the second sample case there are three sums: $$$1 + 2 = 3$$$, $$$1 + 3 = 4$$$, $$$2 + 3 = 5$$$. In binary they are represented as $$$011_2 \oplus 100_2 \oplus 101_2 = 010_2$$$, thus the answer is 2.
$$$\oplus$$$ is the bitwise xor operation. To define $$$x \oplus y$$$, consider binary representations of integers $$$x$$$ and $$$y$$$. We put the $$$i$$$-th bit of the result to be 1 when exactly one of the $$$i$$$-th bits of $$$x$$$ and $$$y$$$ is 1. Otherwise, the $$$i$$$-th bit of the result is put to be 0. For example, $$$0101_2 \, \oplus \, 0011_2 = 0110_2$$$.","#include<bits/stdc++.h> #include<unordered_map> using namespace std; #define ll long long #define pii pair<int,int> //struct Edge { // int from, to, nex; //}edge[400010]; //int tot, head[200010]; //void add(int u, int v) { // edge[++tot] = { u,v,head[u] }; // head[u] = tot; //} ll n; void solve() { cin >> n; vector<ll> a(n + 1); for (int i = 1; i <= n; i++) cin >> a[i]; vector<ll> b(n + 1); ll ans = 0; for (int k = 0; k <= 25; k++) { for (int i = 1; i <= n; i++) { b[i] = (a[i] % (1ll << (k+1))); } sort(b.begin() + 1, b.end()); ll cnt = 0, cnt2 = 0; ll l = 1, r = 1; for (int i = n; i; i--) { /*ll tmp = (1ll << (k - 1)); if (k == 0) tmp = 0;*/ while ( l <= n&&b[l] + b[i] < (1ll<<k)) l++; while ( r <= n&&b[r] + b[i] <= ((1ll << (k+1)) - 1) ) r++; cnt += r - l - (i >= l && i < r); } l = r = 1; for (int i = n; i; i--) { while (l <= n&&b[l] + b[i] < ((1ll << (k + 1))+(1ll<<k)) ) l++; while (r <= n&&(b[r] + b[i] <= ((1ll << (k+2)) -1))) r++; cnt2 += r - l - (i >= l && i < r); } cnt = (cnt >> 1) & 1; cnt2 = (cnt2 >> 1) & 1; if (cnt ^ cnt2) ans += (1ll << k); } cout << ans << '\n'; } signed main() { ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); int tt = 1; // cin >> tt; while (tt--) solve(); return 0; }"
"B. Count Subrectangles
time limit per test
1 second
memory limit per test
512 megabytes
input
standard input
output
standard output
You are given an array $$$a$$$ of length $$$n$$$ and array $$$b$$$ of length $$$m$$$ both consisting of only integers $$$0$$$ and $$$1$$$. Consider a matrix $$$c$$$ of size $$$n \times m$$$ formed by following rule: $$$c_{i, j} = a_i \cdot b_j$$$ (i.e. $$$a_i$$$ multiplied by $$$b_j$$$). It's easy to see that $$$c$$$ consists of only zeroes and ones too.
How many 
subrectangles
 of size (area) $$$k$$$ consisting only of ones are there in $$$c$$$?
A 
subrectangle
 is an intersection of a consecutive (subsequent) segment of rows and a consecutive (subsequent) segment of columns. I.e. consider four integers $$$x_1, x_2, y_1, y_2$$$ ($$$1 \le x_1 \le x_2 \le n$$$, $$$1 \le y_1 \le y_2 \le m$$$) a subrectangle $$$c[x_1 \dots x_2][y_1 \dots y_2]$$$ is an intersection of the rows $$$x_1, x_1+1, x_1+2, \dots, x_2$$$ and the columns $$$y_1, y_1+1, y_1+2, \dots, y_2$$$.
The size (area) of a subrectangle is the total number of cells in it.
Input
The first line contains three integers $$$n$$$, $$$m$$$ and $$$k$$$ ($$$1 \leq n, m \leq 40\,000, 1 \leq k \leq n \cdot m$$$), length of array $$$a$$$, length of array $$$b$$$ and required size of subrectangles.
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \leq a_i \leq 1$$$), elements of $$$a$$$.
The third line contains $$$m$$$ integers $$$b_1, b_2, \ldots, b_m$$$ ($$$0 \leq b_i \leq 1$$$), elements of $$$b$$$.
Output
Output single integer — the number of subrectangles of $$$c$$$ with size (area) $$$k$$$ consisting only of ones.
Examples
Input

3 3 2
1 0 1
1 1 1

Output

4

Input

3 5 4
1 1 1
1 1 1 1 1

Output

14

Note
In first example matrix $$$c$$$ is:
 
 
There are $$$4$$$ subrectangles of size $$$2$$$ consisting of only ones in it:
 
 
In second example matrix $$$c$$$ is:","#include <bits/stdc++.h> #pragma GCC optimize(""O3,Ofast,fast-math"") using namespace std; #define int long long vector <int> a, b; int ac(int x) { int ans = 0; int now = 0; for (int i = 0; i < a.size(); i++) { if (a[i]) now++; else now = 0; if (now >= x) ans++; } return ans; } int bc(int x) { int ans = 0; int now = 0; for (int i = 0; i < b.size(); i++) { if (b[i]) now++; else now = 0; if (now >= x) ans++; } return ans; } signed main() { int n, m; cin >> n >> m; a.resize(n), b.resize(m); int k; cin >> k; for (int i = 0; i < n; i++) cin >> a[i]; for (int j = 0; j < m; j++) cin >> b[j]; long long answer = 0; for (int i = 1; i * i <= k; i++) { if (k % i != 0) continue; answer += ac(i) * bc(k / i); if (i * i != k) answer += ac(k / i) * bc(i); } cout << answer; }"
"B. Yet Another Palindrome Problem
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
You are given an array $$$a$$$ consisting of $$$n$$$ integers.
Your task is to determine if $$$a$$$ has some 
subsequence
 of length at least $$$3$$$ that is a palindrome.
Recall that an array $$$b$$$ is called a 
subsequence
 of the array $$$a$$$ if $$$b$$$ can be obtained by removing some (possibly, zero) elements from $$$a$$$ (not necessarily consecutive) without changing the order of remaining elements. For example, $$$[2]$$$, $$$[1, 2, 1, 3]$$$ and $$$[2, 3]$$$ are subsequences of $$$[1, 2, 1, 3]$$$, but $$$[1, 1, 2]$$$ and $$$[4]$$$ are not.
Also, recall that a palindrome is an array that reads the same backward as forward. In other words, the array $$$a$$$ of length $$$n$$$ is the palindrome if $$$a_i = a_{n - i - 1}$$$ for all $$$i$$$ from $$$1$$$ to $$$n$$$. For example, arrays $$$[1234]$$$, $$$[1, 2, 1]$$$, $$$[1, 3, 2, 2, 3, 1]$$$ and $$$[10, 100, 10]$$$ are palindromes, but arrays $$$[1, 2]$$$ and $$$[1, 2, 3, 1]$$$ are not.
You have to answer $$$t$$$ independent test cases.
Input
The first line of the input contains one integer $$$t$$$ ($$$1 \le t \le 100$$$) — the number of test cases.
Next $$$2t$$$ lines describe test cases. The first line of the test case contains one integer $$$n$$$ ($$$3 \le n \le 5000$$$) — the length of $$$a$$$. The second line of the test case contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le n$$$), where $$$a_i$$$ is the $$$i$$$-th element of $$$a$$$.
It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$5000$$$ ($$$\sum n \le 5000$$$).
Output
For each test case, print the answer — ""
YES
"" (without quotes) if $$$a$$$ has some 
subsequence
 of length at least $$$3$$$ that is a palindrome and ""
NO
"" otherwise.
Example
Input

5
3
1 2 1
5
1 2 2 3 2
3
1 1 2
4
1 2 2 1
10
1 1 2 2 3 3 4 4 5 5

Output

YES
YES
NO
YES
NO

Note
In the first test case of the example, the array $$$a$$$ has a subsequence $$$[1, 2, 1]$$$ which is a palindrome.
In the second test case of the example, the array $$$a$$$ has two subsequences of length $$$3$$$ which are palindromes: $$$[2, 3, 2]$$$ and $$$[2, 2, 2]$$$.
In the third test case of the example, the array $$$a$$$ has no subsequences of length at least $$$3$$$ which are palindromes.
In the fourth test case of the example, the array $$$a$$$ has one subsequence of length $$$4$$$ which is a palindrome: $$$[1, 2, 2, 1]$$$ (and has two subsequences of length $$$3$$$ which are palindromes: both are $$$[1, 2, 1]$$$).
In the fifth test case of the example, the array $$$a$$$ has no subsequences of length at least $$$3$$$ which are palindromes.","#include<bits/stdc++.h> using namespace std; int main() { int x , s , arr[9000]; cin >> x ; while (x--){ cin >> s ; for (int i = 0; i < s ; ++i) { cin >> arr[i]; } bool y = false ; for (int i = 0; i < s ; ++i) { for (int j = i + 2; j < s; ++j) { if (arr[i] == arr[j]) { y = true; break; } } if (y == true) { break; } } if (y == true) { cout << ""Yes"" << endl; } else { cout << ""No"" << endl; } } }"
"B. CopyCopyCopyCopyCopy
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
Ehab has an array $$$a$$$ of length $$$n$$$. He has just enough free time to make a new array consisting of $$$n$$$ copies of the old array, written back-to-back. What will be the length of the new array's longest increasing subsequence?
A sequence $$$a$$$ is a subsequence of an array $$$b$$$ if $$$a$$$ can be obtained from $$$b$$$ by deletion of several (possibly, zero or all) elements. The longest increasing subsequence of an array is the longest subsequence such that its elements are ordered in strictly increasing order.
Input
The first line contains an integer $$$t$$$ — the number of test cases you need to solve. The description of the test cases follows.
The first line of each test case contains an integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of elements in the array $$$a$$$.
The second line contains $$$n$$$ space-separated integers $$$a_1$$$, $$$a_2$$$, $$$\ldots$$$, $$$a_{n}$$$ ($$$1 \le a_i \le 10^9$$$) — the elements of the array $$$a$$$.
The sum of $$$n$$$ across the test cases doesn't exceed $$$10^5$$$.
Output
For each testcase, output the length of the longest increasing subsequence of $$$a$$$ if you concatenate it to itself $$$n$$$ times.
Example
Input

2
3
3 2 1
6
3 1 4 1 5 9

Output

3
5

Note
In the first sample, the new array is $$$[3,2,\textbf{1},3,\textbf{2},1,\textbf{3},2,1]$$$. The longest increasing subsequence is marked in bold.
In the second sample, the longest increasing subsequence will be $$$[1,3,4,5,9]$$$.","#include <bits/stdc++.h> using namespace std; int main() { int t; scanf(""%d"",&t); while (t--) { int n; scanf(""%d"",&n); set<int> s; while (n--) { int a; scanf(""%d"",&a); s.insert(a); } printf(""%d\n"",s.size()); } }"
"B. Maximums
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
Alicia has an array, $$$a_1, a_2, \ldots, a_n$$$, of non-negative integers. For each $$$1 \leq i \leq n$$$, she has found a non-negative integer $$$x_i = max(0, a_1, \ldots, a_{i-1})$$$. Note that for $$$i=1$$$, $$$x_i = 0$$$.
For example, if Alicia had the array $$$a = \{0, 1, 2, 0, 3\}$$$, then $$$x = \{0, 0, 1, 2, 2\}$$$.
Then, she calculated an array, $$$b_1, b_2, \ldots, b_n$$$: $$$b_i = a_i - x_i$$$.
For example, if Alicia had the array $$$a = \{0, 1, 2, 0, 3\}$$$, $$$b = \{0-0, 1-0, 2-1, 0-2, 3-2\} = \{0, 1, 1, -2, 1\}$$$.
Alicia gives you the values $$$b_1, b_2, \ldots, b_n$$$ and asks you to restore the values $$$a_1, a_2, \ldots, a_n$$$. Can you help her solve the problem?
Input
The first line contains one integer $$$n$$$ ($$$3 \leq n \leq 200\,000$$$) – the number of elements in Alicia's array.
The next line contains $$$n$$$ integers, $$$b_1, b_2, \ldots, b_n$$$ ($$$-10^9 \leq b_i \leq 10^9$$$).
It is guaranteed that for the given array $$$b$$$ there is a solution $$$a_1, a_2, \ldots, a_n$$$, for all elements of which the following is true: $$$0 \leq a_i \leq 10^9$$$.
Output
Print $$$n$$$ integers, $$$a_1, a_2, \ldots, a_n$$$ ($$$0 \leq a_i \leq 10^9$$$), such that if you calculate $$$x$$$ according to the statement, $$$b_1$$$ will be equal to $$$a_1 - x_1$$$, $$$b_2$$$ will be equal to $$$a_2 - x_2$$$, ..., and $$$b_n$$$ will be equal to $$$a_n - x_n$$$.
It is guaranteed that there exists at least one solution for the given tests. It can be shown that the solution is unique.
Examples
Input

5
0 1 1 -2 1

Output

0 1 2 0 3 
Input

3
1000 999999000 -1000000000

Output

1000 1000000000 0 
Input

5
2 1 2 2 3

Output

2 3 5 7 10 
Note
The first test was described in the problem statement.
In the second test, if Alicia had an array $$$a = \{1000, 1000000000, 0\}$$$, then $$$x = \{0, 1000, 1000000000\}$$$ and $$$b = \{1000-0, 1000000000-1000, 0-1000000000\} = \{1000, 999999000, -1000000000\}$$$.","#include<bits/stdc++.h> using namespace std; int main(){ long n,b,r=0; cin>>n; for(int i=0;i<n;i++){ cin>>b; cout<<b+r<<"" ""; r=max(r,b+r); } return 0; }"
"B. Princesses and Princes
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
The King of Berland Polycarp LXXXIV has $$$n$$$ daughters. To establish his power to the neighbouring kingdoms he wants to marry his daughters to the princes of these kingdoms. As a lucky coincidence there are $$$n$$$ other kingdoms as well.
So Polycarp LXXXIV has enumerated his daughters from $$$1$$$ to $$$n$$$ and the kingdoms from $$$1$$$ to $$$n$$$. For each daughter he has compiled a list of kingdoms princes of which she wanted to marry.
Polycarp LXXXIV is very busy, so he finds a couple for his daughters greedily one after another.
For the first daughter he takes 
the kingdom with the lowest number from her list
 and marries the daughter to their prince. For the second daughter he takes 
the kingdom with the lowest number from her list, prince of which hasn't been taken already
. If there are no free princes in the list then the daughter marries nobody and Polycarp LXXXIV proceeds to the next daughter. The process ends after the $$$n$$$-th daughter.
For example, let there be $$$4$$$ daughters and kingdoms, the lists daughters have are $$$[2, 3]$$$, $$$[1, 2]$$$, $$$[3, 4]$$$, $$$[3]$$$, respectively.
 
 
In that case daughter $$$1$$$ marries the prince of kingdom $$$2$$$, daughter $$$2$$$ marries the prince of kingdom $$$1$$$, daughter $$$3$$$ marries the prince of kingdom $$$3$$$, leaving daughter $$$4$$$ nobody to marry to.
Actually, before starting the marriage process Polycarp LXXXIV has the time to convince one of his daughters that some prince is also worth marrying to. Effectively, that means that he can add exactly one kingdom to exactly one of his daughter's list. 
Note that this kingdom should not be present in the daughter's list.
Polycarp LXXXIV wants to increase the number of married couples.
Unfortunately, what he doesn't have the time for is determining what entry to add. If there is no way to increase the total number of married couples then output that the marriages are already optimal. Otherwise, find such an entry that the total number of married couples increases if Polycarp LXXXIV adds it.
If there are multiple ways to add an entry so that the total number of married couples increases then print any of them.
For your and our convenience you are asked to answer $$$t$$$ independent test cases.
Input
The first line contains a single integer $$$t$$$ ($$$1 \le t \le 10^5$$$) — the number of test cases.
Then $$$t$$$ test cases follow.
The first line of each test case contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of daughters and the number of kingdoms.
Each of the next $$$n$$$ lines contains the description of each daughter's list. The first integer $$$k$$$ ($$$0 \le k \le n$$$) is the number of entries in the $$$i$$$-th daughter's list. After that $$$k$$$ distinct integers follow $$$g_i[1], g_i[2], \dots, g_i[k]$$$ ($$$1 \le g_i[j] \le n$$$) — the indices of the kingdoms in the list 
in the increasing order
 ($$$g_i[1] < g_i[2] < \dots < g_i[k]$$$).
It's guaranteed that the total number of daughters over all test cases does not exceed $$$10^5$$$.
It's also guaranteed that the total number of kingdoms in lists over all test cases does not exceed $$$10^5$$$.
Output
For each test case print the answer to it.
Print ""
IMPROVE
"" in the first line if Polycarp LXXXIV can add some kingdom to some of his daughter's list so that the total number of married couples increases. The second line then should contain two integers — the index of the daughter and the index of the kingdom Polycarp LXXXIV should add to that daughter's list.
If there are multiple ways to add an entry so that the total number of married couples increases then print any of them.
Otherwise the only line should contain one word ""
OPTIMAL
"".
Example
Input

5
4
2 2 3
2 1 2
2 3 4
1 3
2
0
0
3
3 1 2 3
3 1 2 3
3 1 2 3
1
1 1
4
1 1
1 2
1 3
1 4

Output

IMPROVE
4 4
IMPROVE
1 1
OPTIMAL
OPTIMAL
OPTIMAL

Note
The first test case is depicted in the statement. Adding the fourth kingdom to the list of the fourth daughter makes her marry the prince of the fourth kingdom.
In the second test case any new entry will increase the number of marriages from $$$0$$$ to $$$1$$$.
In the third and the fourth test cases there is no way to add an entry.
In the fifth test case there is no way to change the marriages by adding any entry.","#include<bits/stdc++.h> using namespace std; #define int long long int void h(){ int n;cin>>n; vector<int> vis(n+1,0),mar(n+1,0); for(int i=1;i<=n;i++){ int k;cin>>k; for(int j=0;j<k;j++){ int x;cin>>x; if(!vis[x] && !mar[i]) vis[x]=1,mar[i]=1; } } int f=-1,f2=-1; for(int i=1;i<n+1;i++) if(!vis[i]){f=i;break;} for(int j=1;j<n+1;j++) if(!mar[j]){f2=j;break;} if(f==-1 || f2==-1) cout<<""OPTIMAL""<<endl; else{cout<<""IMPROVE""<<endl;cout<<f2<<"" ""<<f<<endl;} } signed main(){ int t;cin>>t; while(t--){ h(); } }"
"B. K-th Beautiful String
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
For the given integer $$$n$$$ ($$$n > 2$$$) let's write down all the strings of length $$$n$$$ which contain $$$n-2$$$ letters '
a
' and two letters '
b
' in 
lexicographical
 (alphabetical) order.
Recall that the string $$$s$$$ of length $$$n$$$ is lexicographically less than string $$$t$$$ of length $$$n$$$, if there exists such $$$i$$$ ($$$1 \le i \le n$$$), that $$$s_i < t_i$$$, and for any $$$j$$$ ($$$1 \le j < i$$$) $$$s_j = t_j$$$. The lexicographic comparison of strings is implemented by the operator 
<
 in modern programming languages.
For example, if $$$n=5$$$ the strings are (the order does matter):
 
 
aaabb
 
 
aabab
 
 
aabba
 
 
abaab
 
 
ababa
 
 
abbaa
 
 
baaab
 
 
baaba
 
 
babaa
 
 
bbaaa
 
It is easy to show that such a list of strings will contain exactly $$$\frac{n \cdot (n-1)}{2}$$$ strings.
You are given $$$n$$$ ($$$n > 2$$$) and $$$k$$$ ($$$1 \le k \le \frac{n \cdot (n-1)}{2}$$$). Print the $$$k$$$-th string from the list.
Input
The input contains one or more test cases.
The first line contains one integer $$$t$$$ ($$$1 \le t \le 10^4$$$) — the number of test cases in the test. Then $$$t$$$ test cases follow.
Each test case is written on the the separate line containing two integers $$$n$$$ and $$$k$$$ ($$$3 \le n \le 10^5, 1 \le k \le \min(2\cdot10^9, \frac{n \cdot (n-1)}{2})$$$.
The sum of values $$$n$$$ over all test cases in the test doesn't exceed $$$10^5$$$.
Output
For each test case print the $$$k$$$-th string from the list of all described above strings of length $$$n$$$. Strings in the list are sorted lexicographically (alphabetically).
Example
Input

7
5 1
5 2
5 8
5 10
3 1
3 2
20 100

Output

aaabb
aabab
baaba
bbaaa
abb
bab
aaaaabaaaaabaaaaaaaa","#include<bits/stdc++.h> using namespace std; void HelperStartTheEngine(){ int n,k; cin >> n >> k; int cnt = 0; while(1) { int ans = cnt+1; if(ans >= k) { break; } else { k -= ans; } cnt++; } string s = """"; for(int i = 0; i < n; i++) { if((i+cnt+1) == (n-1)) s += 'b'; else if(n-k == i) s += 'b'; else s += 'a'; } // s[n-k] = 'b'; // s[n-cnt-1] = 'b'; cout << s << '\n'; } int main(){ ios::sync_with_stdio(false); cin.tie(NULL); // freopen(""pails.in"", ""r"", stdin); // freopen(""pails.out"", ""w"", stdout); int tt = 1; cin >> tt; int ii = 1; while(tt--){ //cout << ""Case "" << ii++ << "": ""; HelperStartTheEngine(); } return 0; }"
"B. Dreamoon Likes Sequences
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
Dreamoon likes sequences very much. So he created a problem about the sequence that you can't find in OEIS: 
You are given two integers $$$d, m$$$, find the number of arrays $$$a$$$, satisfying the following constraints:
 
 The length of $$$a$$$ is $$$n$$$, $$$n \ge 1$$$ 
 $$$1 \le a_1 < a_2 < \dots < a_n \le d$$$ 
 Define an array $$$b$$$ of length $$$n$$$ as follows: $$$b_1 = a_1$$$, $$$\forall i > 1, b_i = b_{i - 1} \oplus a_i$$$, where $$$\oplus$$$ is the bitwise exclusive-or (xor). After constructing an array $$$b$$$, the constraint $$$b_1 < b_2 < \dots < b_{n - 1} < b_n$$$ should hold. 
Since the number of possible arrays may be too large, you need to find the answer modulo $$$m$$$.
Input
The first line contains an integer $$$t$$$ ($$$1 \leq t \leq 100$$$) denoting the number of test cases in the input.
Each of the next $$$t$$$ lines contains two integers $$$d, m$$$ ($$$1 \leq d, m \leq 10^9$$$).
Note that $$$m$$$ is not necessary the prime!
Output
For each test case, print the number of arrays $$$a$$$, satisfying all given constrains, modulo $$$m$$$.
Example
Input

10
1 1000000000
2 999999999
3 99999998
4 9999997
5 999996
6 99995
7 9994
8 993
9 92
10 1

Output

1
3
5
11
17
23
29
59
89
0","#include<bits/stdc++.h> using namespace std; typedef long long ll; #define endl '\n' const int maxn=3*1e5+11; const int Maxx=5*1e5+11; const int mod=1e9+7; int t; ll d,m; void solve() { cin>>d>>m; ll ans=1; for(int i=0;i<=30;++i) { if(d<(1ll<<i)) break; ans=ans%m*((min((1ll<<(i+1))-1,d)-((1ll<<i)-1)+1)%m)%m; } --ans; ans=(ans+m)%m; cout<<ans<<endl; } int main() { //scanf(""%d"",&t); //ios::sync_with_stdio(false);cin.tie(0); ios::sync_with_stdio(false);cin.tie(0);cin>>t;while(t--) solve(); return 0; }"
"B. Dreamoon Likes Permutations
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
The sequence of $$$m$$$ integers is called the 
permutation
 if it contains all integers from $$$1$$$ to $$$m$$$ exactly once. The number $$$m$$$ is called the length of the permutation.
Dreamoon has two permutations $$$p_1$$$ and $$$p_2$$$ of non-zero lengths $$$l_1$$$ and $$$l_2$$$.
Now Dreamoon concatenates these two permutations into another sequence $$$a$$$ of length $$$l_1 + l_2$$$. First $$$l_1$$$ elements of $$$a$$$ is the permutation $$$p_1$$$ and next $$$l_2$$$ elements of $$$a$$$ is the permutation $$$p_2$$$. 
You are given the sequence $$$a$$$, and you need to find two permutations $$$p_1$$$ and $$$p_2$$$. If there are several possible ways to restore them, you should find all of them. (Note that it is also possible that there will be no ways.)
Input
The first line contains an integer $$$t$$$ ($$$1 \le t \le 10\,000$$$) denoting the number of test cases in the input.
Each test case contains two lines. The first line contains one integer $$$n$$$ ($$$2 \leq n \leq 200\,000$$$): the length of $$$a$$$. The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \leq a_i \leq n-1$$$).
The total sum of $$$n$$$ is less than $$$200\,000$$$.
Output
For each test case, the first line of output should contain one integer $$$k$$$: the number of ways to divide $$$a$$$ into permutations $$$p_1$$$ and $$$p_2$$$.
Each of the next $$$k$$$ lines should contain two integers $$$l_1$$$ and $$$l_2$$$ ($$$1 \leq l_1, l_2 \leq n, l_1 + l_2 = n$$$), denoting, that it is possible to divide $$$a$$$ into two permutations of length $$$l_1$$$ and $$$l_2$$$ ($$$p_1$$$ is the first $$$l_1$$$ elements of $$$a$$$, and $$$p_2$$$ is the last $$$l_2$$$ elements of $$$a$$$). You can print solutions in any order.
Example
Input

6
5
1 4 3 2 1
6
2 4 1 3 2 1
4
2 1 1 3
4
1 3 3 1
12
2 1 3 4 5 6 7 8 9 1 10 2
3
1 1 1

Output

2
1 4
4 1
1
4 2
0
0
1
2 10
0

Note
In the first example, two possible ways to divide $$$a$$$ into permutations are $$$\{1\} + \{4, 3, 2, 1\}$$$ and $$$\{1,4,3,2\} + \{1\}$$$.
In the second example, the only way to divide $$$a$$$ into permutations is $$$\{2,4,1,3\} + \{2,1\}$$$.
In the third example, there are no possible ways.","#include <iostream> #include <bits/stdc++.h> using namespace std; #define len(s) (int)s.size() // using namespace std; using ll = long long; long long gcd(int a,int b) { if(b==0) return a; return gcd(b,a%b); } long long bp(long long a, long long b) { if (b == 0) return 1; long long res = bp(a, b / 2); if (b % 2) return res * res * a >1e9 ? 0 : res*res*a; else return res * res > 1e9 ? 0 : res*res; } ll mod =1e9+7 ; const double error= 1e-9; vector<ll>plist; void seive(){ vector<bool>prime(1e6+1,true); for(int i=2;i*i<1e6+1;i++){ if(prime[i]==false) continue; for(int j=i*i;j<=1e6;j+=i){ prime[j]=false; } } ; for(ll i=2;i<=1e6;i++){ if(prime[i]==true) plist.push_back(i); } // return plist; } ll bleft(ll s, ll e,ll l,vector<ll>&arr,ll x){ ll ans=-1; ll mid; while(s<=e){ mid=(s+e)/2; if(arr[mid]+x >=l ){ ans=mid; e=mid-1; } else{ s=mid+1; } } return ans; } int find(ll l, ll r, ll n, ll d){ ll x= r-l; ll diff= l+d- r +1; ll y= 1e9; if( l+ n-r-1 >= diff ) { y=diff; } return min(x,y); } void solve(){ ll n; cin>>n; vector<ll>arr(n); for(int i=0;i<n;i++){ cin>>arr[i]; } map<ll,ll>pre,suff; ll sum1=0; ll sum2=0; int count=0; vector<pair<ll,ll>> ans; for(int i=n-1;i>0;i--){ sum2++; suff[arr[i]]++; } for(int i=0;i<n-1;i++){ sum1++; pre[arr[i]]++; auto it=pre.end(); it--; ll x=it->first; it=suff.end(); it--; ll y=it->first; if( (pre.size()== x && sum1==x) && (suff.size()==y && sum2==y) ){ count++; ans.push_back({x,y}); } sum2--; suff[arr[i+1]]--; if(suff[arr[i+1]]==0) suff.erase(arr[i+1]); } cout<<count<<endl; for(int i=0;i<count;i++){ cout<<ans[i].first<<"" ""<<ans[i].second<<endl; } } int main() { // your code goes here // seive(); int t; cin>>t; // vector<ll>plist=seive(); while(t--){ solve(); } return 0; }"
"B. Limericks
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
There was once young lass called Mary,  
Whose jokes were occasionally scary.  
On this April's Fool  
Fixed limerick rules  
Allowed her to trip the unwary.
Can she fill all the lines
To work at all times?
On juggling the words
Right around two-thirds
She nearly ran out of rhymes.
Input
The input contains a single integer $$$a$$$ ($$$4 \le a \le 998$$$). Not every integer in the range is a valid input for the problem; you are guaranteed that the input will be a valid integer.
Output
Output a single number.
Examples
Input

35

Output

57

Input

57

Output

319

Input

391

Output

1723",#include <bits/stdc++.h> using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin >> n; for (int i = 2; i <= n; i++) { while (n % i == 0) { cout << i; n /= i; } } return 0; }
"B. Composite Coloring
time limit per test
2 seconds
memory limit per test
512 megabytes
input
standard input
output
standard output
A positive integer is called 
composite
 if it can be represented as a product of two positive integers, both greater than $$$1$$$. For example, the following numbers are composite: $$$6$$$, $$$4$$$, $$$120$$$, $$$27$$$. The following numbers aren't: $$$1$$$, $$$2$$$, $$$3$$$, $$$17$$$, $$$97$$$.
Alice is given a sequence of $$$n$$$ composite numbers $$$a_1,a_2,\ldots,a_n$$$.
She wants to choose an integer $$$m \le 11$$$ and color each element one of $$$m$$$ colors from $$$1$$$ to $$$m$$$ so that:
 
 for each color from $$$1$$$ to $$$m$$$ there is at least one element of this color; 
 each element is colored and colored exactly one color; 
 the greatest common divisor of any two elements that are colored the same color is greater than $$$1$$$, i.e. $$$\gcd(a_i, a_j)>1$$$ for each pair $$$i, j$$$ if these elements are colored the same color. 
Note that equal elements can be colored different colors — you just have to choose one of $$$m$$$ colors for each of the indices from $$$1$$$ to $$$n$$$.
Alice showed already that if all $$$a_i \le 1000$$$ then she can always solve the task by choosing some $$$m \le 11$$$.
Help Alice to find the required coloring. Note that you don't have to minimize or maximize the number of colors, you just have to find the solution with some $$$m$$$ from $$$1$$$ to $$$11$$$.
Input
The first line contains a single integer $$$t$$$ ($$$1 \le t \le 1000$$$) — the number of test cases. Then the descriptions of the test cases follow.
The first line of the test case contains a single integer $$$n$$$ ($$$1 \le n \le 1000$$$) — the amount of numbers in a sequence $$$a$$$.
The second line of the test case contains $$$n$$$ composite integers $$$a_1,a_2,\ldots,a_n$$$ ($$$4 \le a_i \le 1000$$$).
It is guaranteed that the sum of $$$n$$$ over all test cases doesn't exceed $$$10^4$$$.
Output
For each test case print $$$2$$$ lines. The first line should contain a single integer $$$m$$$ ($$$1 \le m \le 11$$$) — the number of used colors. Consider colors to be numbered from $$$1$$$ to $$$m$$$. The second line should contain any coloring that satisfies the above conditions. Print $$$n$$$ integers $$$c_1, c_2, \dots, c_n$$$ ($$$1 \le c_i \le m$$$), where $$$c_i$$$ is the color of the $$$i$$$-th element. If there are multiple solutions then you can print any of them. Note that you don't have to minimize or maximize the number of colors, you just have to find the solution with some $$$m$$$ from $$$1$$$ to $$$11$$$.
Remember that each color from $$$1$$$ to $$$m$$$ should be used at least once. Any two elements of the same color should not be coprime (i.e. their GCD should be greater than $$$1$$$).
Example
Input

3
3
6 10 15
2
4 9
23
437 519 865 808 909 391 194 291 237 395 323 365 511 497 781 737 871 559 731 697 779 841 961

Output

1
1 1 1
2
2 1
11
4 7 8 10 7 3 10 7 7 8 3 1 1 5 5 9 2 2 3 3 4 11 6

Note
In the first test case, $$$\gcd(6,10)=2$$$, $$$\gcd(6,15)=3$$$ and $$$\gcd(10,15)=5$$$. Therefore, it's valid to color all elements the same color. Note that there are other colorings which satisfy Alice's requirement in this test case.
In the second test case there is only one element of each color, so the coloring definitely satisfies Alice's requirement.","#include <bits/stdc++.h> using namespace std; void primeDiv(vector<int> arr, int n){ int prime[12] = {0, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31}; vector<int> primeAlloc(12); vector<bool> validation(12, false); int count = 0; for(int i = 0; i < n; i++){ for(int j = 1; j <= 12; j++){ if(arr[i] % prime[j] == 0) { if(validation[j] == false) { validation[j] = true; count++; primeAlloc[j] = count; } arr[i] = j; } } } cout << count << endl; cout << primeAlloc[arr[0]]; for(int i = 1; i < n; i++) { cout << "" "" << primeAlloc[arr[i]]; } cout << endl; } void answer(){ int n; cin >> n; vector<int> arr(n); for(int i = 0; i < n; i++) cin >> arr[i]; primeDiv(arr, n); } int main(){ int t; cin >> t; while(t--){ answer(); } return 0; }"
"B. Kind Anton
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
Once again, Boris needs the help of Anton in creating a task. This time Anton needs to solve the following problem:
There are two arrays of integers $$$a$$$ and $$$b$$$ of length $$$n$$$. It turned out that array $$$a$$$ contains only elements from the set $$$\{-1, 0, 1\}$$$.
Anton can perform the following sequence of operations any number of times:
 
 Choose any pair of indexes $$$(i, j)$$$ such that $$$1 \le i < j \le n$$$. It is possible to choose the same pair $$$(i, j)$$$ more than once.  
 Add $$$a_i$$$ to $$$a_j$$$. In other words, $$$j$$$-th element of the array becomes equal to $$$a_i + a_j$$$. 
For example, if you are given array $$$[1, -1, 0]$$$, you can transform it only to $$$[1, -1, -1]$$$, $$$[1, 0, 0]$$$ and $$$[1, -1, 1]$$$ by one operation.
Anton wants to predict if it is possible to apply some number (zero or more) of these operations to the array $$$a$$$ so that it becomes equal to array $$$b$$$. Can you help him?
Input
Each test contains multiple test cases. 
The first line contains the number of test cases $$$t$$$ ($$$1 \le t \le 10000$$$). The description of the test cases follows.
The first line of each test case contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$)  — the length of arrays.
The second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$-1 \le a_i \le 1$$$)  — elements of array $$$a$$$. There can be duplicates among elements.
The third line of each test case contains $$$n$$$ integers $$$b_1, b_2, \dots, b_n$$$ ($$$-10^9 \le b_i \le 10^9$$$)  — elements of array $$$b$$$. There can be duplicates among elements.
It is guaranteed that the sum of $$$n$$$ over all test cases doesn't exceed $$$10^5$$$.
Output
For each test case, output one line containing ""
YES
"" if it's possible to make arrays $$$a$$$ and $$$b$$$ equal by performing the described operations, or ""
NO
"" if it's impossible.
You can print each letter in any case (upper or lower).
Example
Input

5
3
1 -1 0
1 1 -2
3
0 1 1
0 2 2
2
1 0
1 41
2
-1 0
-1 -41
5
0 1 -1 1 -1
1 1 -1 1 -1

Output

YES
NO
YES
YES
NO

Note
In the first test-case we can choose $$$(i, j)=(2, 3)$$$ twice and after that choose $$$(i, j)=(1, 2)$$$ twice too. These operations will transform $$$[1, -1, 0] \to [1, -1, -2] \to [1, 1, -2]$$$
In the second test case we can't make equal numbers on the second position.
In the third test case we can choose $$$(i, j)=(1, 2)$$$ $$$41$$$ times. The same about the fourth test case.
In the last lest case, it is impossible to make array $$$a$$$ equal to the array $$$b$$$.","#include<bits/stdc++.h> using namespace std; main(){ int i,j,k,l,m,n,o,p; cin>>p; while(p--){ cin>>n; int x[n],y[n]; for(i=0;i<n;i++)cin>>x[i]; for(i=0;i<n;i++)cin>>y[i]; j=0;k=0;l=0; for(i=0;i<n;i++){ if(x[i]>y[i]&&k==0) l++; else if(x[i]<y[i]&&j==0) l++; if(x[i]==-1) k++; else if(x[i]==1) j++; } if(l==0)cout<<""YES""<<endl; else cout<<""NO""<<endl; } return 0; }"
"B. Middle Class
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
Many years ago Berland was a small country where only $$$n$$$ people lived. Each person had some savings: the $$$i$$$-th one had $$$a_i$$$ burles.
The government considered a person as wealthy if he had at least $$$x$$$ burles. To increase the number of wealthy people Berland decided to carry out several reforms. Each reform looked like that: 
 
 the government chooses some subset of people (maybe all of them); 
 the government takes all savings from the chosen people and redistributes the savings among the chosen people equally. 
For example, consider the savings as list $$$[5, 1, 2, 1]$$$: if the government chose the $$$1$$$-st and the $$$3$$$-rd persons then it, at first, will take all $$$5 + 2 = 7$$$ burles and after that will return $$$3.5$$$ burles to the chosen people. As a result, the savings will become $$$[3.5, 1, 3.5, 1]$$$.
A lot of data was lost from that time, so we don't know how many reforms were implemented and to whom. All we can do is ask you to calculate the maximum possible number of wealthy people after several (maybe zero) reforms.
Input
The first line contains single integer $$$T$$$ ($$$1 \le T \le 1000$$$) — the number of test cases.
Next $$$2T$$$ lines contain the test cases — two lines per test case. The first line contains two integers $$$n$$$ and $$$x$$$ ($$$1 \le n \le 10^5$$$, $$$1 \le x \le 10^9$$$) — the number of people and the minimum amount of money to be considered as wealthy.
The second line contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$) — the initial savings of each person.
It's guaranteed that the total sum of $$$n$$$ doesn't exceed $$$10^5$$$.
Output
Print $$$T$$$ integers — one per test case. For each test case print the maximum possible number of wealthy people after several (maybe zero) reforms.
Example
Input

4
4 3
5 1 2 1
4 10
11 9 11 9
2 5
4 3
3 7
9 4 9

Output

2
4
0
3

Note
The first test case is described in the statement.
In the second test case, the government, for example, could carry out two reforms: $$$[\underline{11}, \underline{9}, 11, 9] \rightarrow [10, 10, \underline{11}, \underline{9}] \rightarrow [10, 10, 10, 10]$$$.
In the third test case, the government couldn't make even one person wealthy.
In the fourth test case, the government could choose all people to carry out a reform: $$$[\underline{9}, \underline{4}, \underline{9}] \rightarrow [7\frac{1}{3}, 7\frac{1}{3}, 7\frac{1}{3}]$$$.","#include <bits/stdc++.h> using namespace std; typedef long long ll; ll arr[111111]; void solve(){ int n; cin >> n; ll x, sum = 0; cin >> x; for(int i = 1; i <= n; ++i) { cin >> arr[i]; } sort(arr + 1, arr + 1 + n); ll ans = 0; for(int i = n; i > 0; --i) { sum += arr[i]; if(sum >= x * (ans + 1)) ans++; else break; } cout << ans << '\n'; } int main(){ ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int t; cin >> t; while(t--) solve(); return 0; }"
"B. Construct the String
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
You are given three positive integers $$$n$$$, $$$a$$$ and $$$b$$$. You have to construct a string $$$s$$$ of length $$$n$$$ consisting of lowercase Latin letters such that 
each substring
 of length $$$a$$$ has 
exactly
 $$$b$$$ distinct letters. It is guaranteed that the answer exists.
You have to answer $$$t$$$ independent test cases.
Recall that the substring $$$s[l \dots r]$$$ is the string $$$s_l, s_{l+1}, \dots, s_{r}$$$ and its length is $$$r - l + 1$$$. In this problem you are only interested in substrings of length $$$a$$$.
Input
The first line of the input contains one integer $$$t$$$ ($$$1 \le t \le 2000$$$) — the number of test cases. Then $$$t$$$ test cases follow.
The only line of a test case contains three space-separated integers $$$n$$$, $$$a$$$ and $$$b$$$ ($$$1 \le a \le n \le 2000, 1 \le b \le \min(26, a)$$$), where $$$n$$$ is the length of the required string, $$$a$$$ is the length of a substring and $$$b$$$ is the required number of distinct letters in each substring of length $$$a$$$.
It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2000$$$ ($$$\sum n \le 2000$$$).
Output
For each test case, print the answer — such a string $$$s$$$ of length $$$n$$$ consisting of lowercase Latin letters that 
each substring
 of length $$$a$$$ has 
exactly
 $$$b$$$ distinct letters. If there are multiple valid answers, print any of them. It is guaranteed that the answer exists.
Example
Input

4
7 5 3
6 1 1
6 6 1
5 2 2

Output

tleelte
qwerty
vvvvvv
abcde

Note
In the first test case of the example, consider all the substrings of length $$$5$$$:
 
 ""
tleel
"": it contains $$$3$$$ distinct (unique) letters, 
 ""
leelt
"": it contains $$$3$$$ distinct (unique) letters, 
 ""
eelte
"": it contains $$$3$$$ distinct (unique) letters.","#include <bits/stdc++.h> using namespace std; int main() { int t; cin>> t; while(t--) { int a, b, c; cin>> a >> b >> c; string ans; string k; int j = 0; for(int i = 0; i < a; i++) { if(j % c == 0) { j = 0; } char c = char('a' + j); k.push_back(c); j++; } cout<< k << endl; } return 0; }"
"B. Xenia and Colorful Gems
time limit per test
3 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
Xenia is a girl being born a noble. Due to the inflexibility and harshness of her family, Xenia has to find some ways to amuse herself.
 
Recently Xenia has bought $$$n_r$$$ red gems, $$$n_g$$$ green gems and $$$n_b$$$ blue gems. Each of the gems has a weight.
Now, she is going to pick three gems.
Xenia loves colorful things, so she will pick exactly one gem of each color.
Xenia loves balance, so she will try to pick gems with little difference in weight.
Specifically, supposing the weights of the picked gems are $$$x$$$, $$$y$$$ and $$$z$$$, Xenia wants to find the minimum value of $$$(x-y)^2+(y-z)^2+(z-x)^2$$$. As her dear friend, can you help her?
Input
The first line contains a single integer $$$t$$$ ($$$1\le t \le 100$$$)  — the number of test cases. Then $$$t$$$ test cases follow.
The first line of each test case contains three integers $$$n_r,n_g,n_b$$$ ($$$1\le n_r,n_g,n_b\le 10^5$$$)  — the number of red gems, green gems and blue gems respectively.
The second line of each test case contains $$$n_r$$$ integers $$$r_1,r_2,\ldots,r_{n_r}$$$ ($$$1\le r_i \le 10^9$$$)  — $$$r_i$$$ is the weight of the $$$i$$$-th red gem.
The third line of each test case contains $$$n_g$$$ integers $$$g_1,g_2,\ldots,g_{n_g}$$$ ($$$1\le g_i \le 10^9$$$)  — $$$g_i$$$ is the weight of the $$$i$$$-th green gem.
The fourth line of each test case contains $$$n_b$$$ integers $$$b_1,b_2,\ldots,b_{n_b}$$$ ($$$1\le b_i \le 10^9$$$)  — $$$b_i$$$ is the weight of the $$$i$$$-th blue gem.
It is guaranteed that $$$\sum n_r \le 10^5$$$, $$$\sum n_g \le 10^5$$$, $$$\sum n_b \le 10^5$$$ (the sum for all test cases).
Output
For each test case, print a line contains one integer  — the minimum value which Xenia wants to find. 
Example
Input

5
2 2 3
7 8
6 3
3 1 4
1 1 1
1
1
1000000000
2 2 2
1 2
5 4
6 7
2 2 2
1 2
3 4
6 7
3 4 1
3 2 1
7 3 3 4
6

Output

14
1999999996000000002
24
24
14

Note
In the first test case, Xenia has the following gems:
If she picks the red gem with weight $$$7$$$, the green gem with weight $$$6$$$, and the blue gem with weight $$$4$$$, she will achieve the most balanced selection with $$$(x-y)^2+(y-z)^2+(z-x)^2=(7-6)^2+(6-4)^2+(4-7)^2=14$$$.","#include<bits/stdc++.h> using namespace std; #define ll long long #define mod (long long)(998244353) void f(ll a[],ll b[],ll c[],ll* ans,int pa,int pb,int pc,ll l,ll r,ll k){ if(pa<0 || pb<0 || pc<0)return; if(pa>=l || pb>=r || pc>=k)return; *ans=min(*ans,(a[pa]-b[pb])*(a[pa]-b[pb])+(a[pa]-c[pc])*(a[pa]-c[pc])+(b[pb]-c[pc])*(b[pb]-c[pc])); } int main() { ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cout << fixed << setprecision(25); cerr << fixed << setprecision(10); auto stat = std::chrono::high_resolution_clock::now(); int t; int n,l,r,k; ll m,val; cin>>t; // t=1; while(t--){ cin>>l>>r>>k; ll a[l],b[r],c[k]; for(auto &x:a)cin>>x; for(auto &x:b)cin>>x; for(auto &x:c)cin>>x; sort(a,a+l); sort(b,b+r); sort(c,c+k); //Answer might be in form x<=y<=z; so if we fix y then we would get the lower_bound and that would be that we // would like to do it for all 2*3 permutations of it ll ans=LLONG_MAX; for(int i=0;i<l;++i){ int lb=lower_bound(b,b+r,a[i])-b; int lbo=lower_bound(c,c+k,a[i])-c; if(lb<r && b[lb]==a[i]){ f(a,b,c,&ans,i,lb,lbo,l,r,k); } --lb; f(a,b,c,&ans,i,lb,lbo,l,r,k); } for(int i=0;i<l;++i){ int lbo=lower_bound(b,b+r,a[i])-b; int lb=lower_bound(c,c+k,a[i])-c; if(lb<k && c[lb]==a[i]){ f(a,b,c,&ans,i,lbo,lb,l,r,k); } --lb; f(a,b,c,&ans,i,lbo,lb,l,r,k); } for(int i=0;i<r;++i){ int lb=lower_bound(a,a+l,b[i])-a; int lbo=lower_bound(c,c+k,b[i])-c; if(lb<l && a[lb]==b[i]){ f(a,b,c,&ans,lb,i,lbo,l,r,k); } --lb; f(a,b,c,&ans,lb,i,lbo,l,r,k); } for(int i=0;i<r;++i){ int lbo=lower_bound(a,a+l,b[i])-a; int lb=lower_bound(c,c+k,b[i])-c; if(lb<k && c[lb]==b[i]){ f(a,b,c,&ans,lbo,i,lb,l,r,k); } --lb; f(a,b,c,&ans,lbo,i,lb,l,r,k); } for(int i=0;i<k;++i){ int lb=lower_bound(a,a+l,c[i])-a; int lbo=lower_bound(b,b+r,c[i])-b; if(lb<l && a[lb]==c[i]){ f(a,b,c,&ans,lb,lbo,i,l,r,k); } --lb; f(a,b,c,&ans,lb,lbo,i,l,r,k); } for(int i=0;i<k;++i){ int lbo=lower_bound(a,a+l,c[i])-a; int lb=lower_bound(b,b+r,c[i])-b; if(lb<r && b[lb]==c[i]){ f(a,b,c,&ans,lbo,lb,i,l,r,k); } --lb; f(a,b,c,&ans,lbo,lb,i,l,r,k); } cout<<ans<<endl; } return 0; }"
"B. Kana and Dragon Quest game
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
Kana was just an ordinary high school girl before a talent scout discovered her. Then, she became an idol. But different from the stereotype, she is also a gameholic. 
One day Kana gets interested in a new adventure game called 
Dragon Quest
. In this game, her quest is to beat a dragon.
 
The dragon has a 
hit point
 of $$$x$$$ initially. When its 
hit point
 goes to $$$0$$$ or under $$$0$$$, it will be defeated. In order to defeat the dragon, Kana can cast the two following types of spells. 
 
Void Absorption
 
Assume that the dragon's current 
hit point
 is $$$h$$$, after 
casting
 this spell its 
hit point
 will become $$$\left\lfloor \frac{h}{2} \right\rfloor + 10$$$. Here $$$\left\lfloor \frac{h}{2} \right\rfloor$$$ denotes $$$h$$$ divided by two, rounded down.
 
Lightning Strike
 
This spell will decrease the dragon's 
hit point
 by $$$10$$$. Assume that the dragon's current 
hit point
 is $$$h$$$, after 
casting
 this spell its 
hit point
 will be lowered to $$$h-10$$$.
Due to some reasons Kana can only 
cast
 
no more than
 $$$n$$$ 
Void Absorptions
 and $$$m$$$ 
Lightning Strikes
. She can cast the spells in any order and 
doesn't have to
 cast all the spells. Kana isn't good at math, so you are going to help her to find out whether it is possible to defeat the dragon.
Input
The first line contains a single integer $$$t$$$ ($$$1 \leq t \leq 1000$$$)  — the number of test cases.
The next $$$t$$$ lines describe test cases. For each test case the only line contains three integers $$$x$$$, $$$n$$$, $$$m$$$ ($$$1\le x \le 10^5$$$, $$$0\le n,m\le30$$$)  — the dragon's intitial 
hit point
, the maximum number of 
Void Absorptions
 and 
Lightning Strikes
 Kana can 
cast
 respectively.
Output
If it is possible to defeat the dragon, print ""
YES
"" (without quotes). Otherwise, print ""
NO
"" (without quotes).
You can print each letter in any case (upper or lower).
Example
Input

7
100 3 4
189 3 4
64 2 3
63 2 3
30 27 7
10 9 1
69117 21 2

Output

YES
NO
NO
YES
YES
YES
YES

Note
One possible casting sequence of the first test case is shown below:
 
Void Absorption
 $$$\left\lfloor \frac{100}{2} \right\rfloor + 10=60$$$.
 
Lightning Strike
 $$$60-10=50$$$.
 
Void Absorption
 $$$\left\lfloor \frac{50}{2} \right\rfloor + 10=35$$$.
 
Void Absorption
 $$$\left\lfloor \frac{35}{2} \right\rfloor + 10=27$$$.
 
Lightning Strike
 $$$27-10=17$$$.
 
Lightning Strike
 $$$17-10=7$$$.
 
Lightning Strike
 $$$7-10=-3$$$.","#include <bits/stdc++.h> using namespace std; int main() { int t; cin>>t; while(t--) { int n,m,k; cin>>n>>m>>k; while(n>0 && m--) { int k1=n/2+10; if(n<=k1) { n=n-10; k--; } else { n=k1; } } n=n-k*10; if(n>0) { cout<<""NO""<<endl; } else { cout<<""YES""<<endl; } } return 0; }"
"B. Edge Weight Assignment
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
You have unweighted tree of $$$n$$$ vertices. You have to assign a 
positive
 weight to each edge so that the following condition would hold:
 
 For every two different leaves $$$v_{1}$$$ and $$$v_{2}$$$ of this tree, 
bitwise XOR
 of weights of all edges on the simple path between $$$v_{1}$$$ and $$$v_{2}$$$ has to be equal to $$$0$$$. 
Note that you can put 
very large
 positive integers (like $$$10^{(10^{10})}$$$).
It's guaranteed that such assignment always exists under given constraints. Now let's define $$$f$$$ as 
the number of distinct weights
 in assignment.
 
 In this example, assignment is valid, because bitwise XOR of all edge weights between every pair of leaves is $$$0$$$. $$$f$$$ value is $$$2$$$ here, because there are $$$2$$$ distinct edge weights($$$4$$$ and $$$5$$$).
 In this example, assignment is invalid, because bitwise XOR of all edge weights between vertex $$$1$$$ and vertex $$$6$$$ ($$$3, 4, 5, 4$$$) is not $$$0$$$. 
What are the minimum and the maximum possible values of $$$f$$$ for the given tree? Find and print both.
Input
The first line contains integer $$$n$$$ ($$$3 \le n \le 10^{5}$$$) — the number of vertices in given tree.
The $$$i$$$-th of the next $$$n-1$$$ lines contains two integers $$$a_{i}$$$ and $$$b_{i}$$$ ($$$1 \le a_{i} \lt b_{i} \le n$$$) — it means there is an edge between $$$a_{i}$$$ and $$$b_{i}$$$. It is guaranteed that given graph forms tree of $$$n$$$ vertices.
Output
Print two integers — the minimum and maximum possible value of $$$f$$$ can be made from valid assignment of given tree. Note that it's always possible to make an assignment under given constraints.
Examples
Input

6
1 3
2 3
3 4
4 5
5 6

Output

1 4

Input

6
1 3
2 3
3 4
4 5
4 6

Output

3 3

Input

7
1 2
2 7
3 4
4 7
5 6
6 7

Output

1 6

Note
In the first example, possible assignments for each minimum and maximum are described in picture below. Of course, there are multiple possible assignments for each minimum and maximum. 
 
 
In the second example, possible assignments for each minimum and maximum are described in picture below. The $$$f$$$ value of valid assignment of this tree is always $$$3$$$. 
 
 
In the third example, possible assignments for each minimum and maximum are described in picture below. Of course, there are multiple possible assignments for each minimum and maximum.","#include <iostream> #include <vector> #include <algorithm> #include <functional> #include <numeric> int main() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); int n; std::cin >> n; int min, max; std::vector<std::vector<int>> e(n); for (int i = 0; i < n - 1; ++i) { int u, v; std::cin >> u >> v; --u; --v; e[u].push_back(v); e[v].push_back(u); } bool even = true; std::function<void(int, int, int)> dfs = [&](int u, int p, int d) { int cnt = 0; for (auto v : e[u]) { if (v == p) continue; ++cnt; dfs(v, u, d + 1); } if (cnt == 0 && d % 2 == 1) even = false; }; int s = 0; while (e[s].size() > 1) ++s; dfs(s, -1, 0); std::vector<int> a(n); for (int i = 0; i < n; ++i) if (e[i].size() == 1) ++a[e[i][0]]; min = even ? 1 : 3; max = n - 1; for (int i = 0; i < n; ++i) if (a[i] > 0) max -= a[i] - 1; std::cout << min << "" "" << max << ""\n""; return 0; }"
"B. Sorted Adjacent Differences
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
You have array of $$$n$$$ numbers $$$a_{1}, a_{2}, \ldots, a_{n}$$$. 
Rearrange these numbers to satisfy $$$|a_{1} - a_{2}| \le |a_{2} - a_{3}| \le \ldots \le |a_{n-1} - a_{n}|$$$, where $$$|x|$$$ denotes absolute value of $$$x$$$. It's always possible to find such rearrangement.
Note that all numbers in $$$a$$$ are not necessarily different. In other words, some numbers of $$$a$$$ may be same.
You have to answer independent $$$t$$$ test cases.
Input
The first line contains a single integer $$$t$$$ ($$$1 \le t \le 10^{4}$$$) — the number of test cases.
The first line of each test case contains single integer $$$n$$$ ($$$3 \le n \le 10^{5}$$$) — the length of array $$$a$$$. It is guaranteed that the sum of values of $$$n$$$ over all test cases in the input does not exceed $$$10^{5}$$$.
The second line of each test case contains $$$n$$$ integers $$$a_{1}, a_{2}, \ldots, a_{n}$$$ ($$$-10^{9} \le a_{i} \le 10^{9}$$$).
Output
For each test case, print the rearranged version of array $$$a$$$ which satisfies given condition. If there are multiple valid rearrangements, print any of them.
Example
Input

2
6
5 -2 4 8 6 5
4
8 1 4 2

Output

5 5 4 6 8 -2
1 2 4 8

Note
In the first test case, after given rearrangement, $$$|a_{1} - a_{2}| = 0 \le |a_{2} - a_{3}| = 1 \le |a_{3} - a_{4}| = 2 \le |a_{4} - a_{5}| = 2 \le |a_{5} - a_{6}| = 10$$$. There are other possible answers like ""
5 4 5 6 -2 8
"".
In the second test case, after given rearrangement, $$$|a_{1} - a_{2}| = 1 \le |a_{2} - a_{3}| = 2 \le |a_{3} - a_{4}| = 4$$$. There are other possible answers like ""
2 4 8 1
"".","#include<bits/stdc++.h> using namespace std; #define ll long long int main() { ll t; cin>>t; while(t--) { ll n; cin>>n; ll arr[n]; ll v[n]; for(int i=0;i<n;i++) { cin>>arr[i]; v[i]=arr[i]; } sort(arr,arr+n); sort(v,v+n,greater<ll>()); ll baki=n-(n/2); ll f=(n/2); ll i=0; ll j=0; vector<ll>ans; //ll cnt=0; while(1) { //cout<<i<<"" ""<<j<<endl; if(baki!=i&&f!=j) { ans.push_back(v[j]); j++; ans.push_back(arr[i]); i++; } else if(baki==i&&f!=j) { ans.push_back(v[j]); j++; } else if(f==j&&baki!=i) { ans.push_back(arr[i]); i++; } else if(baki==i&&f==j) break; } // cout<<cnt<<endl; // cout<<ans.size()<<endl; for(int k=ans.size()-1;k>=0;k--) { cout<<ans[k]<<"" ""; } cout<<endl; } }"
"B. Nastya and Scoreboard
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
 Denis, after buying flowers and sweets (you will learn about this story in the next task), went to a date with Nastya to ask her to become a couple. Now, they are sitting in the cafe and finally... Denis asks her to be together, but ... Nastya doesn't give any answer. 
The poor boy was very upset because of that. He was so sad that he punched some kind of scoreboard with numbers. The numbers are displayed in the same way as on an electronic clock: each digit position consists of $$$7$$$ segments, which can be turned on or off to display different numbers. The picture shows how all $$$10$$$ decimal digits are displayed: 
 
 
After the punch, some segments stopped working, that is, some segments might stop glowing if they glowed earlier. But Denis remembered how many sticks were glowing and how many are glowing now. Denis broke 
exactly
 $$$k$$$ segments and he knows which sticks are working now. Denis came up with the question: what is the maximum possible number that can appear on the board if you turn on exactly $$$k$$$ sticks (which are off now)? 
It is 
allowed
 that the number includes leading zeros.
Input
The first line contains integer $$$n$$$ $$$(1 \leq n \leq 2000)$$$  — the number of digits on scoreboard and $$$k$$$ $$$(0 \leq k \leq 2000)$$$  — the number of segments that stopped working.
The next $$$n$$$ lines contain one binary string of length $$$7$$$, the $$$i$$$-th of which encodes the $$$i$$$-th digit of the scoreboard.
Each digit on the scoreboard consists of $$$7$$$ segments. We number them, as in the picture below, and let the $$$i$$$-th place of the binary string be $$$0$$$ if the $$$i$$$-th stick is not glowing and $$$1$$$ if it is glowing. Then a binary string of length $$$7$$$ will specify which segments are glowing now.
 
 
Thus, the sequences ""1110111"", ""0010010"", ""1011101"", ""1011011"", ""0111010"", ""1101011"", ""1101111"", ""1010010"", ""1111111"", ""1111011"" encode in sequence all digits from $$$0$$$ to $$$9$$$ inclusive.
Output
Output a single number consisting of $$$n$$$ digits  — the maximum number that can be obtained if you turn on exactly $$$k$$$ sticks or $$$-1$$$, if it is impossible to turn on exactly $$$k$$$ sticks so that a correct number appears on the scoreboard digits.
Examples
Input

1 7
0000000

Output

8
Input

2 5
0010010
0010010

Output

97
Input

3 5
0100001
1001001
1010011

Output

-1
Note
In the first test, we are obliged to include all $$$7$$$ sticks and get one $$$8$$$ digit on the scoreboard.
In the second test, we have sticks turned on so that units are formed. For $$$5$$$ of additionally included sticks, you can get the numbers $$$07$$$, $$$18$$$, $$$34$$$, $$$43$$$, $$$70$$$, $$$79$$$, $$$81$$$ and $$$97$$$, of which we choose the maximum  — $$$97$$$.
In the third test, it is impossible to turn on exactly $$$5$$$ sticks so that a sequence of numbers appears on the scoreboard.","#include <bits/stdc++.h> #define nl << ""\n"" #define spc << "" "" << #define pt cout << using namespace std; typedef long long ll; //#define int long long #define pii pair<int, int> int mod = 1e9 + 7; int MAX = 1e9 + 1; int MIN = -1e9; double eps = 1e-7; int check(string &giv,string &req){ int op = 0; for(int i=0;i<7;i++){ if(giv[i] == req[i]) continue; if(req[i] == '1') op ++; else return -1; } return op; } string getAns(vector<string> &arr,vector<string> &numbers,int n,vector<vector<string>> &dp,int k,int idx){ if(idx >= n){ if(k == 0) return """"; else return ""NULL""; } if(dp[idx][k] != ""-1"") return dp[idx][k]; for(int i=9;i>=0;i--){ int t = check(arr[idx], numbers[i]); if(t != -1 && t <= k){ string curr = getAns(arr, numbers, n, dp, k-t, idx+1); if(curr == ""NULL"") continue; curr.push_back(i+'0'); dp[idx][k] = curr; return curr; } } dp[idx][k] = ""NULL""; return ""NULL""; } int main(){ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); vector<string> numbers(10); numbers[0] = ""1110111""; numbers[1] = ""0010010""; numbers[2] = ""1011101""; numbers[3] = ""1011011""; numbers[4] = ""0111010""; numbers[5] = ""1101011""; numbers[6] = ""1101111""; numbers[7] = ""1010010""; numbers[8] = ""1111111""; numbers[9] = ""1111011""; int n,k; cin >> n >> k; vector<string> arr(n); vector<vector<string>> dp(n,vector<string> (k+1,""-1"")); for(int i=0;i<n;i++) cin >> arr[i]; string ans = getAns(arr, numbers, n, dp, k, 0); if(ans == ""NULL"") pt -1 nl; else{ reverse(ans.begin(),ans.end()); pt ans nl; } }"
"B. Nastya and Door
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
On February 14 Denis decided to give Valentine to Nastya and did not come up with anything better than to draw a huge red heart on the door of the length $$$k$$$ ($$$k \ge 3$$$). Nastya was very confused by this present, so she decided to break the door, throwing it on the mountains.
Mountains are described by a sequence of heights $$$a_1, a_2, \dots, a_n$$$ in order from left to right ($$$k \le n$$$). It is guaranteed that neighboring heights are not equal to each other (that is, $$$a_i \ne a_{i+1}$$$ for all $$$i$$$ from $$$1$$$ to $$$n-1$$$).
Peaks of mountains on the segment $$$[l,r]$$$ (from $$$l$$$ to $$$r$$$) are called indexes $$$i$$$ such that $$$l < i < r$$$, $$$a_{i - 1} < a_i$$$ and $$$a_i > a_{i + 1}$$$. It is worth noting that the boundary indexes $$$l$$$ and $$$r$$$ for the segment 
are not peaks
. For example, if $$$n=8$$$ and $$$a=[3,1,4,1,5,9,2,6]$$$, then the segment $$$[1,8]$$$ has only two peaks (with indexes $$$3$$$ and $$$6$$$), and there are no peaks on the segment $$$[3, 6]$$$.
To break the door, Nastya throws it to a segment $$$[l,l+k-1]$$$ of consecutive mountains of length $$$k$$$ ($$$1 \le l \le n-k+1$$$). When the door touches the peaks of the mountains, it breaks into two parts, after that these parts will continue to fall in different halves and also break into pieces when touching the peaks of the mountains, and so on. Formally, the number of parts that the door will break into will be equal to $$$p+1$$$, where $$$p$$$ is the number of peaks on the segment $$$[l,l+k-1]$$$.
Nastya wants to break it into as many pieces as possible. Help her choose such a segment of mountains $$$[l, l+k-1]$$$ that the number of peaks on it is maximum. If there are several optimal segments, Nastya wants to find one for which the value $$$l$$$ is minimal.
Formally, you need to choose a segment of mountains $$$[l, l+k-1]$$$ that has the maximum number of peaks. Among all such segments, you need to find the segment that has the minimum possible value $$$l$$$.
Input
The first line contains an integer $$$t$$$ ($$$1 \leq t \leq 10^4$$$)  — the number of test cases. Then the descriptions of the test cases follow.
The first line of each test case contains two integers $$$n$$$ and $$$k$$$ ($$$3 \leq k \leq n \leq 2 \cdot 10^5$$$)  — the number of mountains and the length of the door.
The second line of the input data set contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$0 \leq a_i \leq 10 ^ 9$$$, $$$a_i \neq a_{i + 1}$$$)  — the heights of mountains.
It is guaranteed that the sum of $$$n$$$ over all the test cases will not exceed $$$2 \cdot 10^5$$$.
Output
For each test case, output two integers $$$t$$$ and $$$l$$$  — the maximum number of parts that the door can split into, and the left border of the segment of length $$$k$$$ that the door should be reset to.
Example
Input

5
8 6
1 2 4 1 2 4 1 2
5 3
3 2 3 2 1
10 4
4 3 4 3 2 3 2 1 0 1
15 7
3 7 4 8 2 3 4 5 21 2 3 4 2 1 3
7 5
1 2 3 4 5 6 1

Output

3 2
2 2
2 1
3 1
2 3

Note
In the first example, you need to select a segment of mountains from $$$2$$$ to $$$7$$$. In this segment, the indexes $$$3$$$ and $$$6$$$ are peaks, so the answer is $$$3$$$ (only $$$2$$$ peaks, so the door will break into $$$3$$$ parts). It is not difficult to notice that the mountain segments $$$[1, 6]$$$ and $$$[3, 8]$$$ are not suitable since they only have a $$$1$$$ peak (for the first segment, the $$$6$$$ index is not a peak, and for the second segment, the $$$3$$$ index is not a peak).
In the second example, you need to select a segment of mountains from $$$2$$$ to $$$4$$$. In this segment, the index $$$3$$$ is a peak, so the answer is $$$2$$$ (only $$$1$$$ peak, so the door will break into $$$2$$$ parts).
In the third example, you need to select a segment of mountains from $$$1$$$ to $$$4$$$. In this segment, the index $$$3$$$ is a peak, so the answer is $$$2$$$ (only $$$1$$$ peak, so the door will break into $$$2$$$ parts). You can see that on the segments $$$[2, 5]$$$, $$$[4, 7]$$$ and $$$[5, 8]$$$ the number of peaks is also $$$1$$$, but these segments have a left border greater than the segment $$$[1, 4]$$$, so they are not the correct answer.","#include <iostream> #include <climits> #include <vector> #include <map> using namespace std; int main() { int t,n,k; cin>>t; while (t--) { int Max_p=0,p=1,l=1; map<int, int>m; cin>>n>>k; int arr[n]; arr[0]=0; for(int i=1;i<=n;i++) cin>>arr[i]; for(int i=2;i<=n-1;i++) { if(arr[i]>arr[i-1] && arr[i]>arr[i+1]) { m[i]++; if(i<k) p++; } } Max_p=p; int end=k;; for(int start=2;start<n-k+2;start++) { if(m[start]) p--; if(m[end]) p++; end++; if(p>Max_p) { l=start; Max_p=p; } } cout<<Max_p<<' '<<l<<endl; } }"
"B. Binary Period
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
Let's say string $$$s$$$ has period $$$k$$$ if $$$s_i = s_{i + k}$$$ for all $$$i$$$ from $$$1$$$ to $$$|s| - k$$$ ($$$|s|$$$ means length of string $$$s$$$) and $$$k$$$ is the minimum positive integer with this property.
Some examples of a period: for $$$s$$$=""
0101
"" the period is $$$k=2$$$, for $$$s$$$=""
0000
"" the period is $$$k=1$$$, for $$$s$$$=""
010
"" the period is $$$k=2$$$, for $$$s$$$=""
0011
"" the period is $$$k=4$$$.
You are given string $$$t$$$ consisting only of 
0
's and 
1
's and you need to find such string $$$s$$$ that:
 
 String $$$s$$$ consists only of 
0
's and 
1
's; 
 The length of $$$s$$$ doesn't exceed $$$2 \cdot |t|$$$; 
 String $$$t$$$ is a subsequence of string $$$s$$$; 
 String $$$s$$$ has smallest possible period among all strings that meet conditions 1—3. 
Let us recall that $$$t$$$ is a subsequence of $$$s$$$ if $$$t$$$ can be derived from $$$s$$$ by deleting zero or more elements (any) without changing the order of the remaining elements. For example, $$$t$$$=""
011
"" is a subsequence of $$$s$$$=""
10101
"".
Input
The first line contains single integer $$$T$$$ ($$$1 \le T \le 100$$$) — the number of test cases.
Next $$$T$$$ lines contain test cases — one per line. Each line contains string $$$t$$$ ($$$1 \le |t| \le 100$$$) consisting only of 
0
's and 
1
's.
Output
Print one string for each test case — string $$$s$$$ you needed to find. If there are multiple solutions print any one of them.
Example
Input

4
00
01
111
110

Output

00
01
11111
1010
Note
In the first and second test cases, $$$s = t$$$ since it's already one of the optimal solutions. Answers have periods equal to $$$1$$$ and $$$2$$$, respectively.
In the third test case, there are shorter optimal solutions, but it's okay since we don't need to minimize the string $$$s$$$. String $$$s$$$ has period equal to $$$1$$$.","#include <bits/stdc++.h> using namespace std; typedef long long ll; typedef pair<ll, ll> pii; const ll mn = 1e6 + 10; ll sum,t; string s; signed main() { cin >> t; while (t--) { ll f1 = 0, f0 = 0; cin >> s; for (ll i = 0; i < s.length(); i++) { if (s[i]=='1') f1++; else f0++; } if (f1 == s.length() || f0 == s.length()) cout << s<<'\n'; else { for (ll i = 0; i < s.length(); i++) { cout << ""10""; } cout << '\n'; } } }"
"B. Balanced Array
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
You are given a positive integer $$$n$$$, it is guaranteed that $$$n$$$ is even (i.e. divisible by $$$2$$$).
You want to construct the array $$$a$$$ of length $$$n$$$ such that: 
 
 The first $$$\frac{n}{2}$$$ elements of $$$a$$$ are even (divisible by $$$2$$$); 
 the second $$$\frac{n}{2}$$$ elements of $$$a$$$ are odd (not divisible by $$$2$$$); 
 
all elements of $$$a$$$ are distinct and positive
; 
 the sum of the first half equals to the sum of the second half ($$$\sum\limits_{i=1}^{\frac{n}{2}} a_i = \sum\limits_{i=\frac{n}{2} + 1}^{n} a_i$$$). 
If there are multiple answers, you can print any. It is 
not guaranteed
 that the answer exists.
You have to answer $$$t$$$ independent test cases.
Input
The first line of the input contains one integer $$$t$$$ ($$$1 \le t \le 10^4$$$) — the number of test cases. Then $$$t$$$ test cases follow.
The only line of the test case contains one integer $$$n$$$ ($$$2 \le n \le 2 \cdot 10^5$$$) — the length of the array. It is guaranteed that that $$$n$$$ is even (i.e. divisible by $$$2$$$).
It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2 \cdot 10^5$$$ ($$$\sum n \le 2 \cdot 10^5$$$).
Output
For each test case, print the answer — ""
NO
"" (without quotes), if there is no suitable answer for the given test case or ""
YES
"" in the first line and 
any
 suitable array $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$) satisfying conditions from the problem statement on the second line.
Example
Input

5
2
4
6
8
10

Output

NO
YES
2 4 1 5
NO
YES
2 4 6 8 1 3 5 11
NO","#include<iostream> using namespace std; int main() { int t,n,i; cin>>t; while(t--) { cin>>n; if((n/2)%2==1) cout<<""NO""<<endl; else { cout<<""YES""<<endl; for(i=1;i<=n/2;i++) { cout<<2*i<<"" ""; } for(i=1;i<n-1;i+=2) { cout<<i<<"" ""; } cout<<(3*n-2)/2<<endl; } } return 0; }"
"B. Monopole Magnets
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
A monopole magnet is a magnet that only has one pole, either north or south. They don't actually exist since real magnets have two poles, but this is a programming contest problem, so we don't care.
There is an $$$n\times m$$$ grid. Initially, you may place some north magnets and some south magnets into the cells. You are allowed to place as many magnets as you like, even multiple in the same cell.
An operation is performed as follows. Choose a north magnet and a south magnet to activate. If they are in the same row or the same column and they occupy different cells, then the north magnet moves one unit closer to the south magnet. Otherwise, if they occupy the same cell or do not share a row or column, then nothing changes. Note that the south magnets are immovable.
Each cell of the grid is colored black or white. Let's consider ways to place magnets in the cells so that the following conditions are met.
 
 There is at least one south magnet in every row and every column. 
 If a cell is colored black, then it is possible for a north magnet to occupy this cell after some sequence of operations 
from the initial placement
. 
 If a cell is colored white, then it is impossible for a north magnet to occupy this cell after some sequence of operations 
from the initial placement
. 
Determine if it is possible to place magnets such that these conditions are met. If it is possible, find the minimum number of north magnets required (there are no requirements on the number of south magnets).
Input
The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1\le n,m\le 1000$$$)  — the number of rows and the number of columns, respectively.
The next $$$n$$$ lines describe the coloring. The $$$i$$$-th of these lines contains a string of length $$$m$$$, where the $$$j$$$-th character denotes the color of the cell in row $$$i$$$ and column $$$j$$$. The characters ""
#
"" and ""
.
"" represent black and white, respectively. It is guaranteed, that the string will not contain any other characters.
Output
Output a single integer, the minimum possible number of north magnets required.
If there is no placement of magnets that satisfies all conditions, print a single integer $$$-1$$$.
Examples
Input

3 3
.#.
###
##.

Output

1

Input

4 2
##
.#
.#
##

Output

-1

Input

4 5
....#
####.
.###.
.#...

Output

2

Input

2 1
.
#

Output

-1

Input

3 5
.....
.....
.....

Output

0

Note
In the first test, here is an example placement of magnets:
 
 
In the second test, we can show that no required placement of magnets exists. Here are three example placements that fail to meet the requirements. The first example violates rule $$$3$$$ since we can move the north magnet down onto a white square. The second example violates rule $$$2$$$ since we cannot move the north magnet to the bottom-left black square by any sequence of operations. The third example violates rule $$$1$$$ since there is no south magnet in the first column.
 
 
In the third test, here is an example placement of magnets. We can show that there is no required placement of magnets with fewer north magnets.
 
 
In the fourth test, we can show that no required placement of magnets exists. Here are two example placements that fail to meet the requirements. The first example violates rule $$$1$$$ since there is no south magnet in the first row. The second example violates rules $$$1$$$ and $$$3$$$ since there is no south magnet in the second row and we can move the north magnet up one unit onto a white square.
 
 
In the fifth test, we can put the south magnet in each cell and no north magnets. Because there are no black cells, it will be a correct placement.","#include <bits/stdc++.h> using namespace std; int main() { int n, m; cin >> n >> m; int a[n][m]; vector<int> row(n, 0), col(m, 0); int rcnt = 0, ccnt = 0; for (int i = 0; i < n; ++i) { for (int j = 0; j < m; ++j) { char c; cin >> c; if (c == '.') a[i][j] = 0; else a[i][j] = 1; } } for (int i = 0; i < n; ++i) { int flag = 0; for (int j = 0; j < m; ++j) { if (a[i][j]) { if (flag == 2) { cout << -1 << endl; return 0; } else if (!flag) rcnt++; flag = 1; } else if (flag == 1) { flag = 2; } } } for (int i = 0; i < m; ++i) { int flag = 0; for (int j = 0; j < n; ++j) { if (a[j][i]) { if (flag == 2) { cout << -1 << endl; return 0; } else if (!flag) ccnt++; flag = 1; } else if (flag == 1) { flag = 2; } } } rcnt = ((n - rcnt) == 0); ccnt = ((m - ccnt) == 0); if ((rcnt ^ ccnt) == 1) {cout << -1 << endl; return 0;} int cnt = 1; queue<int> qx, qy; auto check = [&] (int x, int y) { return x >= 0 && y >= 0 && x < n && y < m; }; const int d[4][2] = {{0,1}, {1,0}, {0,-1}, {-1,0}}; for (int i = 0; i < n; ++i) { for (int j = 0; j < m; ++j) { if (a[i][j] == 1) { qx.push(i); qy.push(j); a[i][j] = ++cnt; while (!qx.empty()) { int curx = qx.front(), cury = qy.front(); for (int t = 0; t < 4; ++t) { int x = curx + d[t][0], y = cury + d[t][1]; if (check(x, y) && a[x][y] == 1) { qx.push(x); qy.push(y); a[x][y] = cnt; } } qx.pop(); qy.pop(); } } } } cout << cnt - 1 << endl; return 0; }"
"B. Card Constructions
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
A card pyramid of height $$$1$$$ is constructed by resting two cards against each other. For $$$h>1$$$, a card pyramid of height $$$h$$$ is constructed by placing a card pyramid of height $$$h-1$$$ onto a base. A base consists of $$$h$$$ pyramids of height $$$1$$$, and $$$h-1$$$ cards on top. For example, card pyramids of heights $$$1$$$, $$$2$$$, and $$$3$$$ look as follows:
 
 
You start with $$$n$$$ cards and build the tallest pyramid that you can. If there are some cards remaining, you build the tallest pyramid possible with the remaining cards. You repeat this process until it is impossible to build another pyramid. In the end, how many pyramids will you have constructed?
Input
Each test consists of multiple test cases. The first line contains a single integer $$$t$$$ ($$$1\le t\le 1000$$$) — the number of test cases. Next $$$t$$$ lines contain descriptions of test cases.
Each test case contains a single integer $$$n$$$ ($$$1\le n\le 10^9$$$) — the number of cards.
It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$10^9$$$.
Output
For each test case output a single integer — the number of pyramids you will have constructed in the end.
Example
Input

5
3
14
15
24
1

Output

1
2
1
3
0

Note
In the first test, you construct a pyramid of height $$$1$$$ with $$$2$$$ cards. There is $$$1$$$ card remaining, which is not enough to build a pyramid.
In the second test, you build two pyramids, each of height $$$2$$$, with no cards remaining.
In the third test, you build one pyramid of height $$$3$$$, with no cards remaining.
In the fourth test, you build one pyramid of height $$$3$$$ with $$$9$$$ cards remaining. Then you build a pyramid of height $$$2$$$ with $$$2$$$ cards remaining. Then you build a final pyramid of height $$$1$$$ with no cards remaining.
In the fifth test, one card is not enough to build any pyramids.",#include <bits/stdc++.h> using namespace std; int h(long long n){ long long height = 0; long long card = 0; long long l = 2; while(card+l<= n){ height++; card += l; l = 2 + (height*3); } n = n - card; if(n>1){ return (1+h(n)); } else if(height>0){ return(1); } else{ return (0); } } int main(){ int t; cin >> t; while(0<t--){ long long n; cin >> n; cout << h(n) << endl; } }
"B. Phoenix and Beauty
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
Phoenix loves beautiful arrays. An array is beautiful if all its subarrays of length $$$k$$$ have the same sum. A subarray of an array is any sequence of consecutive elements.
Phoenix currently has an array $$$a$$$ of length $$$n$$$. He wants to insert some number of integers, possibly zero, into his array such that it becomes beautiful. The inserted integers must be between $$$1$$$ and $$$n$$$ inclusive. Integers may be inserted anywhere (even before the first or after the last element), and he is 
not trying
 to minimize the number of inserted integers.
Input
The input consists of multiple test cases. The first line contains an integer $$$t$$$ ($$$1 \le t \le 50$$$) — the number of test cases.
The first line of each test case contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le k \le n \le 100$$$).
The second line of each test case contains $$$n$$$ space-separated integers ($$$1 \le a_i \le n$$$) — the array that Phoenix currently has. This array may or may not be already beautiful.
Output
For each test case, if it is impossible to create a beautiful array, print 
-1
. Otherwise, print two lines.
The first line should contain the length of the beautiful array $$$m$$$ ($$$n \le m \le 10^4$$$). You don't need to minimize $$$m$$$.
The second line should contain $$$m$$$ space-separated integers ($$$1 \le b_i \le n$$$) — a beautiful array that Phoenix can obtain after inserting some, possibly zero, integers into his array $$$a$$$. You may print integers that weren't originally in array $$$a$$$.
If there are multiple solutions, print any. It's guaranteed that if we can make array $$$a$$$ beautiful, we can always make it with resulting length no more than $$$10^4$$$.
Example
Input

4
4 2
1 2 2 1
4 3
1 2 2 1
3 2
1 2 3
4 4
4 3 4 2

Output

5
1 2 1 2 1
4
1 2 2 1
-1
7
4 3 2 1 4 3 2
Note
In the first test case, we can make array $$$a$$$ beautiful by inserting the integer $$$1$$$ at index $$$3$$$ (in between the two existing $$$2$$$s). Now, all subarrays of length $$$k=2$$$ have the same sum $$$3$$$. There exists many other possible solutions, for example: 
 
 $$$2, 1, 2, 1, 2, 1$$$ 
 $$$1, 2, 1, 2, 1, 2$$$ 
In the second test case, the array is already beautiful: all subarrays of length $$$k=3$$$ have the same sum $$$5$$$.
In the third test case, it can be shown that we cannot insert numbers to make array $$$a$$$ beautiful.
In the fourth test case, the array $$$b$$$ shown is beautiful and all subarrays of length $$$k=4$$$ have the same sum $$$10$$$. There exist other solutions also.","#include <bits/stdc++.h> using namespace std; #define ll long long void solve(); int main(){ int testNumber; cin>>testNumber; while(testNumber--){ solve(); } return 0; } void solve(){ int n,k; cin>>n>>k; set<int> s; for(int i=0;i<n;i++){ int a; cin>>a; s.insert(a); } if(s.size()>k){ cout<<-1<<endl; return; } cout<<n*k<<endl; for(int i=0;i<n;i++){ for(int b:s){ cout<<b<<"" ""; } for(int j=0;j<k-s.size();j++){ cout<<1<<"" ""; } } cout<<endl; }"
"B. Orac and Medians
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
Slime has a sequence of positive integers $$$a_1, a_2, \ldots, a_n$$$.
In one operation Orac can choose an arbitrary subsegment $$$[l \ldots r]$$$ of this sequence and replace all values $$$a_l, a_{l + 1}, \ldots, a_r$$$ to the value of median of $$$\{a_l, a_{l + 1}, \ldots, a_r\}$$$.
In this problem, for the integer multiset $$$s$$$, the median of $$$s$$$ is equal to the $$$\lfloor \frac{|s|+1}{2}\rfloor$$$-th smallest number in it. For example, the median of $$$\{1,4,4,6,5\}$$$ is $$$4$$$, and the median of $$$\{1,7,5,8\}$$$ is $$$5$$$.
Slime wants Orac to make $$$a_1 = a_2 = \ldots = a_n = k$$$ using these operations.
Orac thinks that it is impossible, and he does not want to waste his time, so he decided to ask you if it is possible to satisfy the Slime's requirement, he may ask you these questions several times.
Input
The first line of the input is a single integer $$$t$$$: the number of queries.
The first line of each query contains two integers $$$n\ (1\le n\le 100\,000)$$$ and $$$k\ (1\le k\le 10^9)$$$, the second line contains $$$n$$$ positive integers $$$a_1,a_2,\dots,a_n\ (1\le a_i\le 10^9)$$$
The total sum of $$$n$$$ is at most $$$100\,000$$$.
Output
The output should contain $$$t$$$ lines. The $$$i$$$-th line should be equal to '
yes
' if it is possible to make all integers $$$k$$$ in some number of operations or '
no
', otherwise. You can print each letter in lowercase or uppercase.
Example
Input

5
5 3
1 5 2 6 1
1 6
6
3 2
1 2 3
4 3
3 1 2 3
10 3
1 2 3 4 5 6 7 8 9 10

Output

no
yes
yes
no
yes

Note
In the first query, Orac can't turn all elements into $$$3$$$.
In the second query, $$$a_1=6$$$ is already satisfied.
In the third query, Orac can select the complete array and turn all elements into $$$2$$$.
In the fourth query, Orac can't turn all elements into $$$3$$$.
In the fifth query, Orac can select $$$[1,6]$$$ at first and then select $$$[2,10]$$$.","#include<bits/stdc++.h> using namespace std; void solve() { long long int n, k, ans = false, q = false; cin >> n >> k; vector<long long int>a(n + 1); for(int i = 1; i <= n;i++) { cin >> a[i]; if(a[i] == k) { ans = true; } if(a[i] >= k && ((a[i - 1] >= k && i >= 2) || (a[i - 2] >= k && i >= 3))) { q = true; } } if((ans && n == 1) || (ans && q)) { cout << ""yes"" << '\n'; } else { cout << ""no"" << '\n'; } } int main() { ios_base::sync_with_stdio(NULL); cin.tie(0); cout.tie(0); int t; cin >> t; while(t--) { solve(); } }"
"B. Orac and Models
time limit per test
3 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
There are $$$n$$$ models in the shop numbered from $$$1$$$ to $$$n$$$, with sizes $$$s_1, s_2, \ldots, s_n$$$.
Orac will buy some of the models and will arrange them in the order of increasing numbers (i.e. indices, but not sizes).
Orac thinks that the obtained arrangement is 
beatiful
, if for any two adjacent models with indices $$$i_j$$$ and $$$i_{j+1}$$$ (note that $$$i_j < i_{j+1}$$$, because Orac arranged them properly), $$$i_{j+1}$$$ is divisible by $$$i_j$$$ and $$$s_{i_j} < s_{i_{j+1}}$$$.
For example, for $$$6$$$ models with sizes $$$\{3, 6, 7, 7, 7, 7\}$$$, he can buy models with indices $$$1$$$, $$$2$$$, and $$$6$$$, and the obtained arrangement will be beautiful. Also, note that the arrangement with exactly one model is also considered beautiful.
Orac wants to know the maximum number of models that he can buy, and he may ask you these queries many times.
Input
The first line contains one integer $$$t\ (1 \le t\le 100)$$$: the number of queries.
Each query contains two lines. The first line contains one integer $$$n\ (1\le n\le 100\,000)$$$: the number of models in the shop, and the second line contains $$$n$$$ integers $$$s_1,\dots,s_n\ (1\le s_i\le 10^9)$$$: the sizes of models.
It is guaranteed that the total sum of $$$n$$$ is at most $$$100\,000$$$.
Output
Print $$$t$$$ lines, the $$$i$$$-th of them should contain the maximum number of models that Orac can buy for the $$$i$$$-th query.
Example
Input

4
4
5 3 4 6
7
1 4 2 3 6 4 9
5
5 4 3 2 1
1
9

Output

2
3
1
1

Note
In the first query, for example, Orac can buy models with indices $$$2$$$ and $$$4$$$, the arrangement will be beautiful because $$$4$$$ is divisible by $$$2$$$ and $$$6$$$ is more than $$$3$$$. By enumerating, we can easily find that there are no beautiful arrangements with more than two models. 
In the second query, Orac can buy models with indices $$$1$$$, $$$3$$$, and $$$6$$$. By enumerating, we can easily find that there are no beautiful arrangements with more than three models. 
In the third query, there are no beautiful arrangements with more than one model.","#include <iostream> #include <map> #include <string> #include <vector> #include <set> #include <algorithm> #define ll long long #define pb push_back using namespace std; const int N = 200005; ll a[N]; int c[N]; ll pref[N]; pair<ll, ll> p[N]; vector<int> g[N]; int main() { ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int tt; cin >> tt; while (tt--) { int n; cin >> n; for (int i = 1;i <= n;i++) { cin >> a[i]; } int mx = 0, mx1 = 0; for (int i = 1;i <= n;i++) { c[i] = max(c[i], 1); mx = max(mx, c[i]); for (int j = 2 * i;j <= n;j += i) { if (a[j] > a[i]) { c[j] = max(c[i] + 1, c[j]); mx = max(mx, c[j]); } } } cout << mx << endl; for (int i = 0;i <= n;i++) { c[i] = 0; } } }"
"B. Square?
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
Vasya claims that he had a paper square. He cut it into two rectangular parts using one vertical or horizontal cut. Then Vasya informed you the dimensions of these two rectangular parts. You need to check whether Vasya originally had a square. In other words, check if it is possible to make a square using two given rectangles.
Input
The first line contains an integer $$$t$$$ ($$$1 \le t \le 10^4$$$) — the number of test cases in the input. Then $$$t$$$ test cases follow.
Each test case is given in two lines.
The first line contains two integers $$$a_1$$$ and $$$b_1$$$ ($$$1 \le a_1, b_1 \le 100$$$) — the dimensions of the first one obtained after cutting rectangle. The sizes are given in random order (that is, it is not known which of the numbers is the width, and which of the numbers is the length).
The second line contains two integers $$$a_2$$$ and $$$b_2$$$ ($$$1 \le a_2, b_2 \le 100$$$) — the dimensions of the second obtained after cutting rectangle. The sizes are given in random order (that is, it is not known which of the numbers is the width, and which of the numbers is the length).
Output
Print $$$t$$$ answers, each of which is a string ""
YES
"" (in the case of a positive answer) or ""
NO
"" (in the case of a negative answer). The letters in words can be printed in any case (upper or lower).
Example
Input

3
2 3
3 1
3 2
1 3
3 3
1 3

Output

Yes
Yes
No","#include <bits/stdc++.h> #include <string> #define loop for(int i=1;i<n-1;++i) #define ll long long #define el <<endl; using namespace std; int main() { int t;cin>>t; while(t--) { int a,b,c,d,x; cin>>a>>b>>c>>d; x=max(a,b); cout<<(x==max(c,d)&&min(a,b)+min(c,d)==x?""YES"":""NO"") el } }"
"B. Same Parity Summands
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
You are given two positive integers $$$n$$$ ($$$1 \le n \le 10^9$$$) and $$$k$$$ ($$$1 \le k \le 100$$$). Represent the number $$$n$$$ as the sum of $$$k$$$ positive integers of the same parity (have the same remainder when divided by $$$2$$$).
In other words, find $$$a_1, a_2, \ldots, a_k$$$ such that all $$$a_i>0$$$, $$$n = a_1 + a_2 + \ldots + a_k$$$ and either all $$$a_i$$$ are even or all $$$a_i$$$ are odd at the same time.
If such a representation does not exist, then report it.
Input
The first line contains an integer $$$t$$$ ($$$1 \le t \le 1000$$$) — the number of test cases in the input. Next, $$$t$$$ test cases are given, one per line.
Each test case is two positive integers $$$n$$$ ($$$1 \le n \le 10^9$$$) and $$$k$$$ ($$$1 \le k \le 100$$$).
Output
For each test case print:
 
 
YES
 and the required values $$$a_i$$$, if the answer exists (if there are several answers, print any of them); 
 
NO
 if the answer does not exist. 
The letters in the words 
YES
 and 
NO
 can be printed in any case.
Example
Input

8
10 3
100 4
8 7
97 2
8 8
3 10
5 3
1000000000 9

Output

YES
4 2 4
YES
55 5 5 35
NO
NO
YES
1 1 1 1 1 1 1 1
NO
YES
3 1 1
YES
111111110 111111110 111111110 111111110 111111110 111111110 111111110 111111110 111111120","#include <bits/stdc++.h> #define int long long using namespace std; signed main() { int t; cin >> t; while (t--) { int n, k; cin >> n >> k; int rem = n % k; if (k > n) { cout << ""NO"" << endl; } else if (n == k) { cout << ""YES"" << endl; for (int i = 0; i < n; i++) { cout << 1 << "" ""; } cout << endl; } else if (rem == 0) { cout << ""YES"" << endl; int a = n / k; for (int i = 0; i < k; i++) { cout << a << "" ""; } cout << endl; } else { if (n % 2 != 0 && k % 2 == 0) { cout << ""NO"" << endl; } else if (n % 2 == 0 && k % 2 == 0) { int l = k; cout << ""YES"" << endl; for (int i = 0; i < l - 1; i++) { cout << '1' << "" ""; } cout << n - k + 1 << endl; } else if (n % 2 == 0 && (k % 2 != 0 && n / k > 1)) { int l = k; cout << ""YES"" << endl; for (int i = 0; i < l - 1; i++) { cout << '2' << "" ""; } cout << n - 2 * (k - 1) << endl; } else if (n % 2 != 0) { int l = k; cout << ""YES"" << endl; for (int i = 0; i < l; i++) { int b = n / k; if (b % 2 == 0) { cout << b + 1 << "" ""; n = n - (b + 1); k--; } else { cout << b << "" ""; n = n - b; k--; } } cout << endl; } else { cout << ""NO"" << endl; } } } return 0; }"
"B. Two Arrays And Swaps
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
You are given two arrays $$$a$$$ and $$$b$$$ both consisting of $$$n$$$ positive (greater than zero) integers. You are also given an integer $$$k$$$.
In one move, you can choose two indices $$$i$$$ and $$$j$$$ ($$$1 \le i, j \le n$$$) and swap $$$a_i$$$ and $$$b_j$$$ (i.e. $$$a_i$$$ becomes $$$b_j$$$ and vice versa). Note that $$$i$$$ and $$$j$$$ can be equal or different (in particular, swap $$$a_2$$$ with $$$b_2$$$ or swap $$$a_3$$$ and $$$b_9$$$ both are acceptable moves).
Your task is to find the 
maximum
 possible sum you can obtain in the array $$$a$$$ if you can do no more than (i.e. at most) $$$k$$$ such moves (swaps).
You have to answer $$$t$$$ independent test cases.
Input
The first line of the input contains one integer $$$t$$$ ($$$1 \le t \le 200$$$) — the number of test cases. Then $$$t$$$ test cases follow.
The first line of the test case contains two integers $$$n$$$ and $$$k$$$ ($$$1 \le n \le 30; 0 \le k \le n$$$) — the number of elements in $$$a$$$ and $$$b$$$ and the maximum number of moves you can do. The second line of the test case contains $$$n$$$ integers $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le 30$$$), where $$$a_i$$$ is the $$$i$$$-th element of $$$a$$$. The third line of the test case contains $$$n$$$ integers $$$b_1, b_2, \dots, b_n$$$ ($$$1 \le b_i \le 30$$$), where $$$b_i$$$ is the $$$i$$$-th element of $$$b$$$.
Output
For each test case, print the answer — the 
maximum
 possible sum you can obtain in the array $$$a$$$ if you can do no more than (i.e. at most) $$$k$$$ swaps.
Example
Input

5
2 1
1 2
3 4
5 5
5 5 6 6 5
1 2 5 4 3
5 3
1 2 3 4 5
10 9 10 10 9
4 0
2 2 4 3
2 4 2 3
4 4
1 2 2 1
4 4 5 4

Output

6
27
39
11
17

Note
In the first test case of the example, you can swap $$$a_1 = 1$$$ and $$$b_2 = 4$$$, so $$$a=[4, 2]$$$ and $$$b=[3, 1]$$$.
In the second test case of the example, you don't need to swap anything.
In the third test case of the example, you can swap $$$a_1 = 1$$$ and $$$b_1 = 10$$$, $$$a_3 = 3$$$ and $$$b_3 = 10$$$ and $$$a_2 = 2$$$ and $$$b_4 = 10$$$, so $$$a=[10, 10, 10, 4, 5]$$$ and $$$b=[1, 9, 3, 2, 9]$$$.
In the fourth test case of the example, you cannot swap anything.
In the fifth test case of the example, you can swap arrays $$$a$$$ and $$$b$$$, so $$$a=[4, 4, 5, 4]$$$ and $$$b=[1, 2, 2, 1]$$$.","#include <bits/stdc++.h> using namespace std; int main() { int t,n,k ; cin >> t; for (int i=0; i<t; i++){ cin >> n >> k; int a[n], b[n]; for (int j=0; j<n; j++){ cin >> a[j]; } for (int j=0; j<n; j++){ cin >> b[j]; } sort (a, a+n); sort (b, b+n, greater<int>()); int sum = 0; for (int j=0; j<k; j++){ if (a[j] < b[j]){ a[j] = b[j]; } else { break; } } for (int j=0; j<n; j++){ sum += a[j]; } cout << sum << endl; } return 0; }"
"B. Ternary String
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
You are given a string $$$s$$$ such that each its character is either 
1
, 
2
, or 
3
. You have to choose the shortest contiguous substring of $$$s$$$ such that it contains each of these three characters at least once.
A contiguous substring of string $$$s$$$ is a string that can be obtained from $$$s$$$ by removing some (possibly zero) characters from the beginning of $$$s$$$ and some (possibly zero) characters from the end of $$$s$$$.
Input
The first line contains one integer $$$t$$$ ($$$1 \le t \le 20000$$$) — the number of test cases.
Each test case consists of one line containing the string $$$s$$$ ($$$1 \le |s| \le 200000$$$). It is guaranteed that each character of $$$s$$$ is either 
1
, 
2
, or 
3
.
The sum of lengths of all strings in all test cases does not exceed $$$200000$$$.
Output
For each test case, print one integer — the length of the shortest contiguous substring of $$$s$$$ containing all three types of characters at least once. If there is no such substring, print $$$0$$$ instead.
Example
Input

7
123
12222133333332
112233
332211
12121212
333333
31121

Output

3
3
4
4
0
0
4

Note
Consider the example test:
In the first test case, the substring 
123
 can be used.
In the second test case, the substring 
213
 can be used.
In the third test case, the substring 
1223
 can be used.
In the fourth test case, the substring 
3221
 can be used.
In the fifth test case, there is no character 
3
 in $$$s$$$.
In the sixth test case, there is no character 
1
 in $$$s$$$.
In the seventh test case, the substring 
3112
 can be used.","#include <bits/stdc++.h> using namespace std; #define int long long int signed main() { int t;cin>>t; while(t--) { string s;cin>>s; int p=-1,q=-1,r=-1; int mx=INT_MAX; bool f=false; for(int i=0;i<s.size();i++){ if(s[i]=='1') p=i+1; if(s[i]=='2') q=i+1; if(s[i]=='3') r=i+1; if((p!=-1)&&(q!=-1)&&(r!=-1)){f=true; mx=min(mx,max(p,max(q,r))-min(p,min(q,r))+1); } } if(f)cout<<mx<<endl; else cout<<0<<endl; } return 0; }"
"B. Young Explorers
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
Young wilderness explorers set off to their first expedition led by senior explorer Russell. Explorers went into a forest, set up a camp and decided to split into groups to explore as much interesting locations as possible. Russell was trying to form groups, but ran into some difficulties...
Most of the young explorers are inexperienced, and sending them alone would be a mistake. Even Russell himself became senior explorer not long ago. Each of young explorers has a positive integer parameter $$$e_i$$$ — his inexperience. Russell decided that an explorer with inexperience $$$e$$$ can only join the group of $$$e$$$ or more people.
Now Russell needs to figure out how many groups he can organize. It's not necessary to include every explorer in one of the groups: some can stay in the camp. Russell is worried about this expedition, so he asked you to help him.
Input
The first line contains the number of independent test cases $$$T$$$($$$1 \leq T \leq 2 \cdot 10^5$$$). Next $$$2T$$$ lines contain description of test cases.
The first line of description of each test case contains the number of young explorers $$$N$$$ ($$$1 \leq N \leq 2 \cdot 10^5$$$).
The second line contains $$$N$$$ integers $$$e_1, e_2, \ldots, e_N$$$ ($$$1 \leq e_i \leq N$$$), where $$$e_i$$$ is the inexperience of the $$$i$$$-th explorer.
It's guaranteed that sum of all $$$N$$$ doesn't exceed $$$3 \cdot 10^5$$$.
Output
Print $$$T$$$ numbers, each number on a separate line.
In $$$i$$$-th line print the maximum number of groups Russell can form in $$$i$$$-th test case.
Example
Input

2
3
1 1 1
5
2 3 1 2 2

Output

3
2

Note
In the first example we can organize three groups. There will be only one explorer in each group. It's correct because inexperience of each explorer equals to $$$1$$$, so it's not less than the size of his group.
In the second example we can organize two groups. Explorers with inexperience $$$1$$$, $$$2$$$ and $$$3$$$ will form the first group, and the other two explorers with inexperience equal to $$$2$$$ will form the second group.
This solution is not unique. For example, we can form the first group using the three explorers with inexperience equal to $$$2$$$, and the second group using only one explorer with inexperience equal to $$$1$$$. In this case the young explorer with inexperience equal to $$$3$$$ will not be included in any group.","#include <bits/stdc++.h> using namespace std; int main() { int t; cin >> t; while (t--) { int n; cin >> n; vector <int> a(n); for (int i = 0; i < n; i++) { cin >> a[i]; } sort(a.begin(), a.end()); int ans = 0, cur = 0; for (int i = 0; i < n; i++) { if (++cur == a[i]) { ans++; cur = 0; } } cout << ans << '\n'; } return 0; }"
"B. Maria Breaks the Self-isolation
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
Maria is the most active old lady in her house. She was tired of sitting at home. She decided to organize a ceremony against the coronavirus.
She has $$$n$$$ friends who are also grannies (Maria is not included in this number). The $$$i$$$-th granny is ready to attend the ceremony, provided that at the time of her appearance in the courtyard there will be at least $$$a_i$$$ other grannies there. Note that grannies can come into the courtyard at the same time. Formally, the granny $$$i$$$ agrees to come if the number of other grannies who came earlier or at the same time with her is greater than or equal to $$$a_i$$$.
Grannies gather in the courtyard like that.
 
 Initially, only Maria is in the courtyard (that is, the initial number of grannies in the courtyard is $$$1$$$). All the remaining $$$n$$$ grannies are still sitting at home.
 On each step Maria selects a subset of grannies, none of whom have yet to enter the courtyard. She promises each of them that at the time of her appearance there will be at least $$$a_i$$$ other grannies (including Maria) in the courtyard. Maria can call several grannies at once. In this case, the selected grannies will go out into the courtyard 
at the same moment of time
.
 She cannot deceive grannies, that is, the situation when the $$$i$$$-th granny in the moment of appearing in the courtyard, finds that now there are strictly less than $$$a_i$$$ other grannies (except herself, but including Maria), is prohibited. Please note that if several grannies appeared in the yard at the same time, then each of them sees others at the time of appearance. 
Your task is to find what maximum number of grannies (including herself) Maria can collect in the courtyard for the ceremony. After all, the more people in one place during quarantine, the more effective the ceremony!
Consider an example: if $$$n=6$$$ and $$$a=[1,5,4,5,1,9]$$$, then:
 
 at the first step Maria can call grannies with numbers $$$1$$$ and $$$5$$$, each of them will see two grannies at the moment of going out into the yard (note that $$$a_1=1 \le 2$$$ and $$$a_5=1 \le 2$$$); 
 at the second step, Maria can call grannies with numbers $$$2$$$, $$$3$$$ and $$$4$$$, each of them will see five grannies at the moment of going out into the yard (note that $$$a_2=5 \le 5$$$, $$$a_3=4 \le 5$$$ and $$$a_4=5 \le 5$$$); 
 the $$$6$$$-th granny cannot be called into the yard  — therefore, the answer is $$$6$$$ (Maria herself and another $$$5$$$ grannies). 
Input
The first line contains a single integer $$$t$$$ ($$$1 \le t \le 10^4$$$) — the number of test cases in the input. Then test cases follow.
The first line of a test case contains a single integer $$$n$$$ ($$$1 \le n \le 10^5$$$) — the number of grannies (Maria is not included in this number).
The second line contains $$$n$$$ integers $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \le a_i \le 2\cdot10^5$$$).
It is guaranteed that the sum of the values $$$n$$$ over all test cases of the input does not exceed $$$10^5$$$.
Output
For each test case, print a single integer $$$k$$$ ($$$1 \le k \le n + 1$$$) — the maximum possible number of grannies in the courtyard.
Example
Input

4
5
1 1 2 2 1
6
2 3 4 5 6 7
6
1 5 4 5 1 9
5
1 2 3 5 6

Output

6
1
6
4

Note
In the first test case in the example, on the first step Maria can call all the grannies. Then each of them will see five grannies when they come out. Therefore, Maria and five other grannies will be in the yard.
In the second test case in the example, no one can be in the yard, so Maria will remain there alone.
The third test case in the example is described in the details above.
In the fourth test case in the example, on the first step Maria can call grannies with numbers $$$1$$$, $$$2$$$ and $$$3$$$. If on the second step Maria calls $$$4$$$ or $$$5$$$ (one of them), then when a granny appears in the yard, she will see only four grannies (but it is forbidden). It means that Maria can't call the $$$4$$$-th granny or the $$$5$$$-th granny separately (one of them). If she calls both: $$$4$$$ and $$$5$$$, then when they appear, they will see $$$4+1=5$$$ grannies. Despite the fact that it is enough for the $$$4$$$-th granny, the $$$5$$$-th granny is not satisfied. So, Maria cannot call both the $$$4$$$-th granny and the $$$5$$$-th granny at the same time. That is, Maria and three grannies from the first step will be in the yard in total.","#include<bits/stdc++.h> using namespace std; const int maxn=1e5+10; #define int long long signed main() { int t; cin>>t; while(t--) { int n,i; cin>>n; int a[n+1]; for( i=1;i<=n;i++) cin>>a[i]; sort(a+1,a+1+n); for(i=n;a[i]>i&&i>0;i--); cout<<i+1<<endl; } }"
"B. New Theatre Square
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
You might have remembered Theatre square from the 
problem 1A
. Now it's finally getting repaved.
The square still has a rectangular shape of $$$n \times m$$$ meters. However, the picture is about to get more complicated now. Let $$$a_{i,j}$$$ be the $$$j$$$-th square in the $$$i$$$-th row of the pavement.
You are given the picture of the squares:
 
 if $$$a_{i,j} = $$$ ""
*
"", then the $$$j$$$-th square in the $$$i$$$-th row should be 
black
; 
 if $$$a_{i,j} = $$$ ""
.
"", then the $$$j$$$-th square in the $$$i$$$-th row should be 
white
. 
The black squares are paved already. You have to pave the white squares. There are two options for pavement tiles:
 
 $$$1 \times 1$$$ tiles — each tile costs $$$x$$$ burles and covers exactly $$$1$$$ square; 
 $$$1 \times 2$$$ tiles — each tile costs $$$y$$$ burles and covers exactly $$$2$$$ adjacent squares of the 
same row
. 
Note that you are not allowed to rotate these tiles or cut them into $$$1 \times 1$$$ tiles.
 
You should cover all the white squares, no two tiles should overlap and no black squares should be covered by tiles.
What is the smallest total price of the tiles needed to cover all the white squares?
Input
The first line contains a single integer $$$t$$$ ($$$1 \le t \le 500$$$) — the number of testcases. Then the description of $$$t$$$ testcases follow.
The first line of each testcase contains four integers $$$n$$$, $$$m$$$, $$$x$$$ and $$$y$$$ ($$$1 \le n \le 100$$$; $$$1 \le m \le 1000$$$; $$$1 \le x, y \le 1000$$$) — the size of the Theatre square, the price of the $$$1 \times 1$$$ tile and the price of the $$$1 \times 2$$$ tile.
Each of the next $$$n$$$ lines contains $$$m$$$ characters. The $$$j$$$-th character in the $$$i$$$-th line is $$$a_{i,j}$$$. If $$$a_{i,j} = $$$ ""
*
"", then the $$$j$$$-th square in the $$$i$$$-th row should be black, and if $$$a_{i,j} = $$$ ""
.
"", then the $$$j$$$-th square in the $$$i$$$-th row should be white.
It's guaranteed that the sum of $$$n \times m$$$ over all testcases doesn't exceed $$$10^5$$$.
Output
For each testcase print a single integer — the smallest total price of the tiles needed to cover all the white squares in burles.
Example
Input

4
1 1 10 1
.
1 2 10 1
..
2 1 10 1
.
.
3 3 3 7
..*
*..
.*.

Output

10
1
20
18

Note
In the first testcase you are required to use a single $$$1 \times 1$$$ tile, even though $$$1 \times 2$$$ tile is cheaper. So the total price is $$$10$$$ burles.
In the second testcase you can either use two $$$1 \times 1$$$ tiles and spend $$$20$$$ burles or use a single $$$1 \times 2$$$ tile and spend $$$1$$$ burle. The second option is cheaper, thus the answer is $$$1$$$.
The third testcase shows that you can't rotate $$$1 \times 2$$$ tiles. You still have to use two $$$1 \times 1$$$ tiles for the total price of $$$20$$$.
In the fourth testcase the cheapest way is to use $$$1 \times 1$$$ tiles everywhere. The total cost is $$$6 \cdot 3 = 18$$$.","#include <iostream> using namespace std; int main() { int t; cin >> t; while (t--) { int n, m, x, y; cin >> n >> m >> x >> y; long long s = 0; if (y > x * 2) y = x * 2; for (int i = 0; i < n; i++) { string a; cin >> a; for (int j = 0; j < m; j++) { if (j != m - 1) { if (a[j] == a[j + 1] && a[j] == '.') { s += y; j++; } else if (a[j] == '.') s += x; } else { if (a[j] == '.') s += x; } } } cout << s << endl; s = 0; } }"
"B. Honest Coach
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
There are $$$n$$$ athletes in front of you. Athletes are numbered from $$$1$$$ to $$$n$$$ from left to right. You know the strength of each athlete — the athlete number $$$i$$$ has the strength $$$s_i$$$.
You want to split all athletes into two teams. Each team must have at least one athlete, and each athlete must be exactly in one team.
You want the strongest athlete from the first team to differ as little as possible from the weakest athlete from the second team. Formally, you want to split the athletes into two teams $$$A$$$ and $$$B$$$ so that the value $$$|\max(A) - \min(B)|$$$ is as small as possible, where $$$\max(A)$$$ is the maximum strength of an athlete from team $$$A$$$, and $$$\min(B)$$$ is the minimum strength of an athlete from team $$$B$$$.
For example, if $$$n=5$$$ and the strength of the athletes is $$$s=[3, 1, 2, 6, 4]$$$, then one of the possible split into teams is: 
 
 first team: $$$A = [1, 2, 4]$$$, 
 second team: $$$B = [3, 6]$$$. 
In this case, the value $$$|\max(A) - \min(B)|$$$ will be equal to $$$|4-3|=1$$$. This example illustrates one of the ways of optimal split into two teams.
Print the minimum value $$$|\max(A) - \min(B)|$$$.
Input
The first line contains an integer $$$t$$$ ($$$1 \le t \le 1000$$$) — the number of test cases in the input. Then $$$t$$$ test cases follow.
Each test case consists of two lines. 
The first line contains positive integer $$$n$$$ ($$$2 \le n \le 50$$$) — number of athletes. 
The second line contains $$$n$$$ positive integers $$$s_1, s_2, \ldots, s_n$$$ ($$$1 \le s_i \le 1000$$$), where $$$s_i$$$ — is the strength of the $$$i$$$-th athlete. Please note that $$$s$$$ values may not be distinct.
Output
For each test case print one integer — the minimum value of $$$|\max(A) - \min(B)|$$$ with the optimal split of all athletes into two teams. Each of the athletes must be a member of exactly one of the two teams.
Example
Input

5
5
3 1 2 6 4
6
2 1 3 2 4 3
4
7 9 3 1
2
1 1000
3
100 150 200

Output

1
0
2
999
50

Note
The first test case was explained in the statement. In the second test case, one of the optimal splits is $$$A=[2, 1]$$$, $$$B=[3, 2, 4, 3]$$$, so the answer is $$$|2-2|=0$$$.","#include <bits/stdc++.h> using namespace std; int main() { ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); int t; cin >> t; while (t--) { int n; cin >> n; vector<int>vec(n); for (auto& i : vec) { cin >> i; } sort(vec.begin(), vec.end()); vector<int>diff; for (int i = 0; i < vec.size() - 1; i++) { diff.push_back(vec[i + 1]-vec[i]); } cout << *min_element(diff.begin(), diff.end()) << ""\n""; } }"
"B. Johnny and Grandmaster
time limit per test
2 seconds
memory limit per test
256 megabytes
input
standard input
output
standard output
Johnny has just found the new, great tutorial: ""
How to become a grandmaster?
"". The tutorial tells many strange and unexpected for Johnny things, such as you have to be patient or that very important is solving many harder and harder problems. 
The boy has found an online judge with tasks divided by topics they cover. He has picked $$$p^{k_i}$$$ problems from $$$i$$$-th category ($$$p$$$ is his favorite number). He wants to solve them in two weeks (the patience condition is too hard for Johnny, so for simplicity, he looks only at easy tasks, which can be solved in such a period). Now our future grandmaster has to decide which topics to cover first and which the second week. Help him assign topics in such a way, that workload is balanced.
Formally, given $$$n$$$ numbers $$$p^{k_i}$$$, the boy wants to divide them into two disjoint sets, minimizing the absolute difference between sums of numbers in each set. Find the minimal absolute difference. Output the result modulo $$$10^{9}+7$$$.
Input
Input consists of multiple test cases. The first line contains one integer $$$t$$$ $$$(1 \leq t \leq 10^5)$$$ — the number of test cases. Each test case is described as follows:
The first line contains two integers $$$n$$$ and $$$p$$$ $$$(1 \leq n, p \leq 10^6)$$$. The second line contains $$$n$$$ integers $$$k_i$$$ $$$(0 \leq k_i \leq 10^6)$$$.
The sum of $$$n$$$ over all test cases doesn't exceed $$$10^6$$$.
Output
Output one integer — the reminder of division the answer by $$$1\,000\,000\,007$$$.
Example
Input

4
5 2
2 3 4 4 3
3 1
2 10 1000
4 5
0 1 1 100
1 8
89

Output

4
1
146981438
747093407

Note
You have to minimize the difference, not it's remainder. For example, if the minimum difference is equal to $$$2$$$, but there is also a distribution where the difference is $$$10^9 + 8$$$, then the answer is $$$2$$$, not $$$1$$$.
In the first test case of the example, there're the following numbers: $$$4$$$, $$$8$$$, $$$16$$$, $$$16$$$, and $$$8$$$. We can divide them into such two sets: $$${4, 8, 16}$$$ and $$${8, 16}$$$. Then the difference between the sums of numbers in sets would be $$$4$$$.","#include <iostream> #include <cstring> #include <algorithm> #include <vector> using namespace std; const int N = 1e6+10,mod=1e9+7,md=1e9+3; typedef long long LL; int n,m; int a[N]; int qmi(int a, int k, int p) // ?a^k mod p { int res = 1 % p; while (k) { if (k & 1) res = (LL)res * a % p; a = (LL)a * a % p; k >>= 1; } return res; } void solve(){ cin>>n>>m; for(int i=1;i<=n;i++) cin>>a[i]; sort(a+1,a+1+n,greater<>()); vector<int> st; int ans=0,res=0; for(int i=1;i<=n;i++){ if(!ans&&!res){ ans=qmi(m,a[i],mod),res=qmi(m,a[i],md); } else{ ans-=qmi(m,a[i],mod); ans=(ans+mod)%mod; res-=qmi(m,a[i],md); res=(res+md)%md; } } cout<<ans<<""\n""; } int main() { cin.tie(0); cout.tie(0); ios::sync_with_stdio(0); int t; cin>>t; while(t--) solve(); }"
"B. Johnny and His Hobbies
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
Among Johnny's numerous hobbies, there are two seemingly harmless ones: applying bitwise operations and sneaking into his dad's office. As it is usually the case with small children, Johnny is unaware that combining these two activities can get him in a lot of trouble.
There is a set $$$S$$$ containing very important numbers on his dad's desk. The minute Johnny heard about it, he decided that it's a good idea to choose a 
positive
 integer $$$k$$$ and replace each element $$$s$$$ of the set $$$S$$$ with $$$s \oplus k$$$ ($$$\oplus$$$ denotes the 
exclusive or
 operation). 
Help him choose such $$$k$$$ that Johnny's dad will not see any difference after his son is done playing (i.e. Johnny will get the same set as before playing). It is possible that no such number exists. It is also possible that there are many of them. In such a case, output the smallest one. Note that the order of elements in a set doesn't matter, i.e. set $$$\{1, 2, 3\}$$$ equals to set $$$\{2, 1, 3\}$$$.
Formally, find the smallest positive integer $$$k$$$ such that $$$\{s \oplus k | s \in S\} = S$$$ or report that there is no such number.
For example, if $$$S = \{1, 3, 4\}$$$ and $$$k = 2$$$, new set will be equal to $$$\{3, 1, 6\}$$$. If $$$S = \{0, 1, 2, 3\}$$$ and $$$k = 1$$$, after playing set will stay the same.
Input
In the first line of input, there is a single integer $$$t$$$ ($$$1 \leq t \leq 1024$$$), the number of test cases. In the next lines, $$$t$$$ test cases follow. Each of them consists of two lines. 
In the first line there is a single integer $$$n$$$ ($$$1 \leq n \leq 1024$$$) denoting the number of elements in set $$$S$$$. Second line consists of $$$n$$$ 
distinct
 integers $$$s_i$$$ ($$$0 \leq s_i < 1024$$$), elements of $$$S$$$.
It is guaranteed that the sum of $$$n$$$ over all test cases will not exceed $$$1024$$$.
Output
Print $$$t$$$ lines; $$$i$$$-th line should contain the answer to the $$$i$$$-th test case, the minimal positive integer $$$k$$$ satisfying the conditions or $$$-1$$$ if no such $$$k$$$ exists.
Example
Input

6
4
1 0 2 3
6
10 7 14 8 3 12
2
0 2
3
1 2 3
6
1 4 6 10 11 12
2
0 1023

Output

1
4
2
-1
-1
1023

Note
In the first test case, the answer is $$$1$$$ because it is a minimum positive integer and it satisfies all the conditions.","#include <bits/stdc++.h> using namespace std; #define int long long int n; string s; int32_t main(){ int t; cin>>t; while(t--){ cin>>n; vector<int> a(n); for(auto &it:a) cin>>it; sort(a.begin(), a.end()); int i; for( i=1; i<1025; i++){ vector<int> b; for(auto it: a) b.push_back(it^i); sort(b.begin(), b.end()); if(a==b) {cout<<i<<endl; break;} } if(i==1025) cout<<-1<<endl; } }"
"B. Subsequence Hate
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
Shubham has a binary string $$$s$$$. A binary string is a string containing only characters ""
0
"" and ""
1
"".
He can perform the following operation on the string any amount of times: 
 
 Select an index of the string, and flip the character at that index. This means, if the character was ""
0
"", it becomes ""
1
"", and vice versa. 
A string is called good if it does not contain ""
010
"" or ""
101
"" as a subsequence  — for instance, ""
1001
"" contains ""
101
"" as a subsequence, hence it is not a good string, while ""
1000
"" doesn't contain neither ""
010
"" nor ""
101
"" as subsequences, so it is a good string.
What is the minimum number of operations he will have to perform, so that the string becomes good? It can be shown that with these operations we can make any string good.
A string $$$a$$$ is a subsequence of a string $$$b$$$ if $$$a$$$ can be obtained from $$$b$$$ by deletion of several (possibly, zero or all) characters.
Input
The first line of the input contains a single integer $$$t$$$ $$$(1\le t \le 100)$$$ — the number of test cases.
Each of the next $$$t$$$ lines contains a binary string $$$s$$$ $$$(1 \le |s| \le 1000)$$$.
Output
For every string, output the minimum number of operations required to make it good.
Example
Input

7
001
100
101
010
0
1
001100

Output

0
0
1
1
0
0
2

Note
In test cases $$$1$$$, $$$2$$$, $$$5$$$, $$$6$$$ no operations are required since they are already good strings.
For the $$$3$$$rd test case: ""
001
"" can be achieved by flipping the first character  — and is one of the possible ways to get a good string.
For the $$$4$$$th test case: ""
000
"" can be achieved by flipping the second character  — and is one of the possible ways to get a good string.
For the $$$7$$$th test case: ""
000000
"" can be achieved by flipping the third and fourth characters  — and is one of the possible ways to get a good string.","#include <bits/stdc++.h> #include <iostream> #include <algorithm> #include <bits/stdc++.h> #define ull unsigned long long #define ll long long #define all(v) v.begin(),v.end() using namespace std; void fast(){ cin.tie(0); cout.tie(0); cin.sync_with_stdio(0); } int main() { fast(); ll t = 1; cin >> t; while (t--) { string s; cin >> s ; ll n = s.length() ; ll ones = 0 , zeros= 0 ; for (int i = 0; i < n; ++i) { ones+= (s[i] == '1') ; zeros += (s[i] == '0') ; } ll leftze =0 ; ll leftone = 0 ; ll mini = min(zeros , ones ) ; for (int i = 0; i < n; ++i) { leftze += (s[i] == '0') ; leftone+= (s[i] == '1') ; ll x = min(leftze, leftone) ; ll y = min(zeros - leftze, ones - leftone) ; mini = min(mini, x+y) ; } cout << mini <<""\n"" ; } }"
"B. Most socially-distanced subsequence
time limit per test
1 second
memory limit per test
256 megabytes
input
standard input
output
standard output
Given a permutation $$$p$$$ of length $$$n$$$, find its subsequence $$$s_1$$$, $$$s_2$$$, $$$\ldots$$$, $$$s_k$$$ of length at least $$$2$$$ such that:
 
 $$$|s_1-s_2|+|s_2-s_3|+\ldots+|s_{k-1}-s_k|$$$ is as big as possible over all subsequences of $$$p$$$ with length at least $$$2$$$. 
 Among all such subsequences, choose the one whose length, $$$k$$$, is as small as possible. 
If multiple subsequences satisfy these conditions, you are allowed to find any of them.
A sequence $$$a$$$ is a subsequence of an array $$$b$$$ if $$$a$$$ can be obtained from $$$b$$$ by deleting some (possibly, zero or all) elements.
A permutation of length $$$n$$$ is an array of length $$$n$$$ in which every element from $$$1$$$ to $$$n$$$ occurs exactly once.
Input
The first line contains an integer $$$t$$$ ($$$1 \le t \le 2 \cdot 10^4$$$) — the number of test cases. The description of the test cases follows.
The first line of each test case contains an integer $$$n$$$ ($$$2 \le n \le 10^5$$$) — the length of the permutation $$$p$$$.
The second line of each test case contains $$$n$$$ integers $$$p_1$$$, $$$p_2$$$, $$$\ldots$$$, $$$p_{n}$$$ ($$$1 \le p_i \le n$$$, $$$p_i$$$ are distinct) — the elements of the permutation $$$p$$$.
The sum of $$$n$$$ across the test cases doesn't exceed $$$10^5$$$.
Output
For each test case, the first line should contain the length of the found subsequence, $$$k$$$. The second line should contain $$$s_1$$$, $$$s_2$$$, $$$\ldots$$$, $$$s_k$$$ — its elements.
If multiple subsequences satisfy these conditions, you are allowed to find any of them.
Example
Input

2
3
3 2 1
4
1 3 4 2

Output

2
3 1 
3
1 4 2 

Note
In the first test case, there are $$$4$$$ subsequences of length at least $$$2$$$:
 
 $$$[3,2]$$$ which gives us $$$|3-2|=1$$$. 
 $$$[3,1]$$$ which gives us $$$|3-1|=2$$$. 
 $$$[2,1]$$$ which gives us $$$|2-1|=1$$$. 
 $$$[3,2,1]$$$ which gives us $$$|3-2|+|2-1|=2$$$. 
So the answer is either $$$[3,1]$$$ or $$$[3,2,1]$$$. Since we want the subsequence to be as short as possible, the answer is $$$[3,1]$$$.","#include<bits/stdc++.h> using namespace std; #define int long long void s() { int n; cin>>n; vector<int>v(n); for(int i=0;i<n;i++)cin>>v[i]; int d=0; for(int i=0;i<n-1;i++) { d+=abs(v[i+1]-v[i]); } vector<int>ans; ans.push_back(v[0]); for(int i=1;i<n-1;i++) { if(abs(v[i-1]-v[i])+abs(v[i+1]-v[i])==abs(v[i+1]-v[i-1])) continue; else ans.push_back(v[i]); } ans.push_back(v[n-1]); cout<<ans.size()<<""\n""; for(int i=0;i<ans.size();i++) { cout<<ans[i]<<"" ""; } cout<<""\n""; } int32_t main() { int t; cin>>t; while(t--)s(); }"
